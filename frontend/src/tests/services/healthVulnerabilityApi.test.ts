/**
 * Health and Vulnerability API Service Tests (Cycle 6)
 *
 * TDD Red Phase: These tests define expected behavior for the API service layer
 * that does not yet exist. All tests should FAIL initially.
 *
 * Coverage:
 * - Health Conditions:
 *   - fetchHealthProductOwners (GET /health/product-owners)
 *   - fetchHealthSpecialRelationships (GET /health/special-relationships)
 *   - createHealthRecord (POST /health/product-owners or /health/special-relationships)
 *   - updateHealthRecord (PUT /health/product-owners/:id or /health/special-relationships/:id)
 *   - deleteHealthRecord (DELETE /health/product-owners/:id or /health/special-relationships/:id)
 *
 * - Vulnerabilities:
 *   - fetchVulnerabilitiesProductOwners (GET /vulnerabilities/product-owners)
 *   - fetchVulnerabilitiesSpecialRelationships (GET /vulnerabilities/special-relationships)
 *   - createVulnerability (POST /vulnerabilities/product-owners or /vulnerabilities/special-relationships)
 *   - updateVulnerability (PUT /vulnerabilities/product-owners/:id or /vulnerabilities/special-relationships/:id)
 *   - deleteVulnerability (DELETE /vulnerabilities/product-owners/:id or /vulnerabilities/special-relationships/:id)
 *
 * Error scenarios:
 * - 400 Bad Request (validation errors)
 * - 401 Unauthorized (authentication failures)
 * - 404 Not Found (resource not found)
 * - 422 Validation Error (detailed field errors)
 * - 500 Internal Server Error (server failures)
 *
 * @module tests/services/healthVulnerabilityApi.test
 */

import {
  fetchHealthProductOwners,
  fetchHealthSpecialRelationships,
  fetchVulnerabilitiesProductOwners,
  fetchVulnerabilitiesSpecialRelationships,
  createHealthRecord,
  updateHealthRecord,
  deleteHealthRecord,
  createVulnerability,
  updateVulnerability,
  deleteVulnerability,
  // Validation functions
  validateHealthData,
  validateVulnerabilityData,
  // Error handling
  getUserFriendlyErrorMessage,
  // Utilities
  debounce,
  // Types
  type ValidationError,
  type ValidationResult,
} from '@/services/healthVulnerabilityApi';

import type {
  HealthProductOwner,
  HealthSpecialRelationship,
  VulnerabilityProductOwner,
  VulnerabilitySpecialRelationship,
  HealthProductOwnerCreate,
  HealthSpecialRelationshipCreate,
  HealthConditionUpdate,
  VulnerabilityProductOwnerCreate,
  VulnerabilitySpecialRelationshipCreate,
  VulnerabilityUpdate,
  PersonType,
} from '@/types/healthVulnerability';

// Mock the API module
jest.mock('@/services/api', () => ({
  __esModule: true,
  default: {
    get: jest.fn(),
    post: jest.fn(),
    put: jest.fn(),
    delete: jest.fn(),
  },
}));

import api from '@/services/api';

const mockedApi = api as jest.Mocked<typeof api>;

// =============================================================================
// Test Data Factories
// =============================================================================

/**
 * Creates a mock HealthProductOwner record for testing
 */
function createMockHealthProductOwner(
  overrides: Partial<HealthProductOwner> = {}
): HealthProductOwner {
  return {
    id: 1,
    product_owner_id: 100,
    condition: 'Diabetes',
    name: 'Type 2 Diabetes',
    date_of_diagnosis: '2020-05-15',
    status: 'Active',
    medication: 'Metformin 500mg',
    notes: 'Monitor blood sugar levels regularly',
    created_at: '2025-01-01T10:00:00Z',
    date_recorded: '2025-01-01T10:00:00Z',
    ...overrides,
  };
}

/**
 * Creates a mock HealthSpecialRelationship record for testing
 */
function createMockHealthSpecialRelationship(
  overrides: Partial<HealthSpecialRelationship> = {}
): HealthSpecialRelationship {
  return {
    id: 10,
    special_relationship_id: 200,
    condition: 'Dementia',
    name: "Early-stage Alzheimer's",
    date_of_diagnosis: '2023-03-20',
    status: 'Active',
    medication: 'Donepezil',
    notes: 'Requires supervision for financial decisions',
    created_at: '2025-01-01T12:00:00Z',
    date_recorded: null,
    ...overrides,
  };
}

/**
 * Creates a mock VulnerabilityProductOwner record for testing
 */
function createMockVulnerabilityProductOwner(
  overrides: Partial<VulnerabilityProductOwner> = {}
): VulnerabilityProductOwner {
  return {
    id: 1,
    product_owner_id: 100,
    description: 'Cognitive decline affecting financial decisions',
    adjustments: 'Speak slowly, provide written summaries',
    diagnosed: true,
    status: 'Active',
    notes: 'Family member should be present at meetings',
    created_at: '2025-01-01T10:00:00Z',
    date_recorded: '2025-01-01T10:00:00Z',
    ...overrides,
  };
}

/**
 * Creates a mock VulnerabilitySpecialRelationship record for testing
 */
function createMockVulnerabilitySpecialRelationship(
  overrides: Partial<VulnerabilitySpecialRelationship> = {}
): VulnerabilitySpecialRelationship {
  return {
    id: 10,
    special_relationship_id: 200,
    description: 'Recent bereavement affecting judgment',
    adjustments: 'Delay major financial decisions if possible',
    diagnosed: false,
    status: 'Monitoring',
    notes: 'Review in 6 months',
    created_at: '2025-01-01T12:00:00Z',
    date_recorded: null,
    ...overrides,
  };
}

describe('Health and Vulnerability API Service', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  // ===========================================================================
  // HEALTH CONDITIONS - FETCH
  // ===========================================================================
  describe('fetchHealthProductOwners', () => {
    const clientGroupId = 50;

    it('should fetch all health records for product owners in a client group', async () => {
      const mockHealthRecords = [
        createMockHealthProductOwner({ id: 1, product_owner_id: 100 }),
        createMockHealthProductOwner({ id: 2, product_owner_id: 101, condition: 'Asthma' }),
        createMockHealthProductOwner({ id: 3, product_owner_id: 100, condition: 'Arthritis' }),
      ];

      mockedApi.get.mockResolvedValueOnce({
        data: mockHealthRecords,
      });

      const result = await fetchHealthProductOwners(clientGroupId);

      expect(mockedApi.get).toHaveBeenCalledWith('/health/product-owners', {
        params: { client_group_id: clientGroupId },
      });
      expect(result).toEqual(mockHealthRecords);
      expect(result).toHaveLength(3);
    });

    it('should return empty array when no health records exist', async () => {
      mockedApi.get.mockResolvedValueOnce({
        data: [],
      });

      const result = await fetchHealthProductOwners(clientGroupId);

      expect(result).toEqual([]);
    });

    it('should throw error on unauthorized access (401)', async () => {
      mockedApi.get.mockRejectedValueOnce({
        response: {
          status: 401,
          data: {
            error: 'Unauthorized',
            message: 'Authentication credentials were not provided or are invalid',
          },
        },
      });

      await expect(fetchHealthProductOwners(clientGroupId)).rejects.toThrow(
        'Authentication credentials were not provided or are invalid'
      );
    });

    it('should throw error on server failure (500)', async () => {
      mockedApi.get.mockRejectedValueOnce({
        response: {
          status: 500,
          data: {
            error: 'InternalServerError',
            message: 'An unexpected error occurred. Please try again later.',
          },
        },
      });

      await expect(fetchHealthProductOwners(clientGroupId)).rejects.toThrow(
        'An unexpected error occurred'
      );
    });
  });

  describe('fetchHealthSpecialRelationships', () => {
    const clientGroupId = 50;

    it('should fetch all health records for special relationships in a client group', async () => {
      const mockHealthRecords = [
        createMockHealthSpecialRelationship({ id: 10, special_relationship_id: 200 }),
        createMockHealthSpecialRelationship({ id: 11, special_relationship_id: 201, condition: 'Heart Disease' }),
      ];

      mockedApi.get.mockResolvedValueOnce({
        data: mockHealthRecords,
      });

      const result = await fetchHealthSpecialRelationships(clientGroupId);

      expect(mockedApi.get).toHaveBeenCalledWith('/health/special-relationships', {
        params: { client_group_id: clientGroupId },
      });
      expect(result).toEqual(mockHealthRecords);
      expect(result).toHaveLength(2);
    });

    it('should return empty array when no health records exist', async () => {
      mockedApi.get.mockResolvedValueOnce({
        data: [],
      });

      const result = await fetchHealthSpecialRelationships(clientGroupId);

      expect(result).toEqual([]);
    });

    it('should throw error on unauthorized access (401)', async () => {
      mockedApi.get.mockRejectedValueOnce({
        response: {
          status: 401,
          data: {
            error: 'Unauthorized',
            message: 'Authentication credentials were not provided or are invalid',
          },
        },
      });

      await expect(fetchHealthSpecialRelationships(clientGroupId)).rejects.toThrow(
        'Authentication credentials were not provided or are invalid'
      );
    });
  });

  // ===========================================================================
  // HEALTH CONDITIONS - CREATE
  // ===========================================================================
  describe('createHealthRecord', () => {
    describe('for product owners', () => {
      it('should successfully create a health record for a product owner', async () => {
        const createData: HealthProductOwnerCreate = {
          product_owner_id: 100,
          condition: 'Diabetes',
          name: 'Type 2 Diabetes',
          date_of_diagnosis: '2020-05-15',
          status: 'Active',
          medication: 'Metformin 500mg',
          notes: 'Monitor blood sugar levels regularly',
        };

        const mockCreatedRecord = createMockHealthProductOwner({
          id: 1,
          ...createData,
          created_at: '2025-01-09T10:00:00Z',
        });

        mockedApi.post.mockResolvedValueOnce({
          data: mockCreatedRecord,
        });

        const result = await createHealthRecord(createData, 'product_owner');

        expect(mockedApi.post).toHaveBeenCalledWith('/health/product-owners', createData);
        expect(result.id).toBe(1);
        expect(result.condition).toBe('Diabetes');
        expect(result.status).toBe('Active');
      });

      it('should create a health record with minimal required fields', async () => {
        const minimalData: HealthProductOwnerCreate = {
          product_owner_id: 101,
          condition: 'Asthma',
        };

        const mockCreatedRecord = createMockHealthProductOwner({
          id: 2,
          product_owner_id: 101,
          condition: 'Asthma',
          name: null,
          date_of_diagnosis: null,
          status: 'Active',
          medication: null,
          notes: null,
        });

        mockedApi.post.mockResolvedValueOnce({
          data: mockCreatedRecord,
        });

        const result = await createHealthRecord(minimalData, 'product_owner');

        expect(mockedApi.post).toHaveBeenCalledWith('/health/product-owners', minimalData);
        expect(result.id).toBe(2);
        expect(result.condition).toBe('Asthma');
      });

      it('should throw validation error when required fields are missing (422)', async () => {
        const invalidData = {
          product_owner_id: 100,
          // condition is missing
        };

        mockedApi.post.mockRejectedValueOnce({
          response: {
            status: 422,
            data: {
              error: 'ValidationError',
              message: 'Request validation failed',
              details: {
                condition: 'Condition is required',
              },
            },
          },
        });

        await expect(
          createHealthRecord(invalidData as HealthProductOwnerCreate, 'product_owner')
        ).rejects.toThrow('Request validation failed');
      });

      it('should throw error when product owner does not exist (404)', async () => {
        const createData: HealthProductOwnerCreate = {
          product_owner_id: 99999,
          condition: 'Test Condition',
        };

        mockedApi.post.mockRejectedValueOnce({
          response: {
            status: 404,
            data: {
              error: 'NotFound',
              message: "Product owner with id '99999' not found",
            },
          },
        });

        await expect(createHealthRecord(createData, 'product_owner')).rejects.toThrow(
          "Product owner with id '99999' not found"
        );
      });

      it('should throw error when date of diagnosis is in the future', async () => {
        const futureDate = new Date();
        futureDate.setFullYear(futureDate.getFullYear() + 1);
        const futureDateString = futureDate.toISOString().split('T')[0];

        const createData: HealthProductOwnerCreate = {
          product_owner_id: 100,
          condition: 'Test Condition',
          date_of_diagnosis: futureDateString,
        };

        mockedApi.post.mockRejectedValueOnce({
          response: {
            status: 422,
            data: {
              error: 'ValidationError',
              message: 'Request validation failed',
              details: {
                date_of_diagnosis: 'Date of diagnosis cannot be in the future',
              },
            },
          },
        });

        await expect(createHealthRecord(createData, 'product_owner')).rejects.toThrow(
          'Request validation failed'
        );
      });
    });

    describe('for special relationships', () => {
      it('should successfully create a health record for a special relationship', async () => {
        const createData: HealthSpecialRelationshipCreate = {
          special_relationship_id: 200,
          condition: 'Dementia',
          name: "Early-stage Alzheimer's",
          status: 'Active',
          medication: 'Donepezil',
          notes: 'Requires supervision',
        };

        const mockCreatedRecord = createMockHealthSpecialRelationship({
          id: 10,
          ...createData,
          date_of_diagnosis: null,
          created_at: '2025-01-09T10:00:00Z',
        });

        mockedApi.post.mockResolvedValueOnce({
          data: mockCreatedRecord,
        });

        const result = await createHealthRecord(createData, 'special_relationship');

        expect(mockedApi.post).toHaveBeenCalledWith('/health/special-relationships', createData);
        expect(result.id).toBe(10);
        expect(result.condition).toBe('Dementia');
      });
    });
  });

  // ===========================================================================
  // HEALTH CONDITIONS - UPDATE
  // ===========================================================================
  describe('updateHealthRecord', () => {
    describe('for product owners', () => {
      const healthRecordId = 1;

      it('should successfully update a health record', async () => {
        const updateData: HealthConditionUpdate = {
          status: 'Resolved',
          notes: 'Condition has been resolved with treatment',
        };

        const mockUpdatedRecord = createMockHealthProductOwner({
          id: healthRecordId,
          status: 'Resolved',
          notes: 'Condition has been resolved with treatment',
        });

        mockedApi.put.mockResolvedValueOnce({
          data: mockUpdatedRecord,
        });

        const result = await updateHealthRecord(healthRecordId, updateData, 'product_owner');

        expect(mockedApi.put).toHaveBeenCalledWith(
          `/health/product-owners/${healthRecordId}`,
          updateData
        );
        expect(result.status).toBe('Resolved');
        expect(result.notes).toBe('Condition has been resolved with treatment');
      });

      it('should update only specified fields (partial update)', async () => {
        const updateData: HealthConditionUpdate = {
          medication: 'New medication',
        };

        const mockUpdatedRecord = createMockHealthProductOwner({
          id: healthRecordId,
          medication: 'New medication',
        });

        mockedApi.put.mockResolvedValueOnce({
          data: mockUpdatedRecord,
        });

        const result = await updateHealthRecord(healthRecordId, updateData, 'product_owner');

        expect(mockedApi.put).toHaveBeenCalledWith(
          `/health/product-owners/${healthRecordId}`,
          updateData
        );
        expect(result.medication).toBe('New medication');
      });

      it('should throw error when health record not found (404)', async () => {
        const updateData: HealthConditionUpdate = {
          status: 'Resolved',
        };

        mockedApi.put.mockRejectedValueOnce({
          response: {
            status: 404,
            data: {
              error: 'NotFound',
              message: `Health record with id '${healthRecordId}' not found`,
            },
          },
        });

        await expect(
          updateHealthRecord(healthRecordId, updateData, 'product_owner')
        ).rejects.toThrow(`Health record with id '${healthRecordId}' not found`);
      });

      it('should throw validation error on invalid status value', async () => {
        const updateData = {
          status: 'InvalidStatus',
        };

        mockedApi.put.mockRejectedValueOnce({
          response: {
            status: 422,
            data: {
              error: 'ValidationError',
              message: 'Request validation failed',
              details: {
                status: 'Status must be one of: Active, Resolved, Monitoring, Inactive',
              },
            },
          },
        });

        await expect(
          updateHealthRecord(healthRecordId, updateData as HealthConditionUpdate, 'product_owner')
        ).rejects.toThrow('Request validation failed');
      });

      it('should throw error on unauthorized access (401)', async () => {
        const updateData: HealthConditionUpdate = {
          status: 'Resolved',
        };

        mockedApi.put.mockRejectedValueOnce({
          response: {
            status: 401,
            data: {
              error: 'Unauthorized',
              message: 'Authentication credentials were not provided or are invalid',
            },
          },
        });

        await expect(
          updateHealthRecord(healthRecordId, updateData, 'product_owner')
        ).rejects.toThrow('Authentication credentials were not provided or are invalid');
      });
    });

    describe('for special relationships', () => {
      const healthRecordId = 10;

      it('should successfully update a health record for special relationship', async () => {
        const updateData: HealthConditionUpdate = {
          status: 'Monitoring',
          notes: 'Updated notes for monitoring',
        };

        const mockUpdatedRecord = createMockHealthSpecialRelationship({
          id: healthRecordId,
          status: 'Monitoring',
          notes: 'Updated notes for monitoring',
        });

        mockedApi.put.mockResolvedValueOnce({
          data: mockUpdatedRecord,
        });

        const result = await updateHealthRecord(healthRecordId, updateData, 'special_relationship');

        expect(mockedApi.put).toHaveBeenCalledWith(
          `/health/special-relationships/${healthRecordId}`,
          updateData
        );
        expect(result.status).toBe('Monitoring');
      });
    });
  });

  // ===========================================================================
  // HEALTH CONDITIONS - DELETE
  // ===========================================================================
  describe('deleteHealthRecord', () => {
    describe('for product owners', () => {
      const healthRecordId = 1;

      it('should successfully delete a health record', async () => {
        mockedApi.delete.mockResolvedValueOnce({
          status: 204,
          data: null,
        });

        await deleteHealthRecord(healthRecordId, 'product_owner');

        expect(mockedApi.delete).toHaveBeenCalledWith(
          `/health/product-owners/${healthRecordId}`
        );
      });

      it('should throw error when health record not found (404)', async () => {
        mockedApi.delete.mockRejectedValueOnce({
          response: {
            status: 404,
            data: {
              error: 'NotFound',
              message: `Health record with id '${healthRecordId}' not found`,
            },
          },
        });

        await expect(deleteHealthRecord(healthRecordId, 'product_owner')).rejects.toThrow(
          `Health record with id '${healthRecordId}' not found`
        );
      });

      it('should throw error on unauthorized access (401)', async () => {
        mockedApi.delete.mockRejectedValueOnce({
          response: {
            status: 401,
            data: {
              error: 'Unauthorized',
              message: 'Authentication credentials were not provided or are invalid',
            },
          },
        });

        await expect(deleteHealthRecord(healthRecordId, 'product_owner')).rejects.toThrow(
          'Authentication credentials were not provided or are invalid'
        );
      });

      it('should throw error on server failure (500)', async () => {
        mockedApi.delete.mockRejectedValueOnce({
          response: {
            status: 500,
            data: {
              error: 'InternalServerError',
              message: 'An unexpected error occurred. Please try again later.',
            },
          },
        });

        await expect(deleteHealthRecord(healthRecordId, 'product_owner')).rejects.toThrow(
          'An unexpected error occurred'
        );
      });
    });

    describe('for special relationships', () => {
      const healthRecordId = 10;

      it('should successfully delete a health record for special relationship', async () => {
        mockedApi.delete.mockResolvedValueOnce({
          status: 204,
          data: null,
        });

        await deleteHealthRecord(healthRecordId, 'special_relationship');

        expect(mockedApi.delete).toHaveBeenCalledWith(
          `/health/special-relationships/${healthRecordId}`
        );
      });
    });
  });

  // ===========================================================================
  // VULNERABILITIES - FETCH
  // ===========================================================================
  describe('fetchVulnerabilitiesProductOwners', () => {
    const clientGroupId = 50;

    it('should fetch all vulnerability records for product owners in a client group', async () => {
      const mockVulnerabilityRecords = [
        createMockVulnerabilityProductOwner({ id: 1, product_owner_id: 100 }),
        createMockVulnerabilityProductOwner({
          id: 2,
          product_owner_id: 101,
          description: 'Hearing impairment',
        }),
      ];

      mockedApi.get.mockResolvedValueOnce({
        data: mockVulnerabilityRecords,
      });

      const result = await fetchVulnerabilitiesProductOwners(clientGroupId);

      expect(mockedApi.get).toHaveBeenCalledWith('/vulnerabilities/product-owners', {
        params: { client_group_id: clientGroupId },
      });
      expect(result).toEqual(mockVulnerabilityRecords);
      expect(result).toHaveLength(2);
    });

    it('should return empty array when no vulnerability records exist', async () => {
      mockedApi.get.mockResolvedValueOnce({
        data: [],
      });

      const result = await fetchVulnerabilitiesProductOwners(clientGroupId);

      expect(result).toEqual([]);
    });

    it('should throw error on unauthorized access (401)', async () => {
      mockedApi.get.mockRejectedValueOnce({
        response: {
          status: 401,
          data: {
            error: 'Unauthorized',
            message: 'Authentication credentials were not provided or are invalid',
          },
        },
      });

      await expect(fetchVulnerabilitiesProductOwners(clientGroupId)).rejects.toThrow(
        'Authentication credentials were not provided or are invalid'
      );
    });

    it('should throw error on server failure (500)', async () => {
      mockedApi.get.mockRejectedValueOnce({
        response: {
          status: 500,
          data: {
            error: 'InternalServerError',
            message: 'An unexpected error occurred. Please try again later.',
          },
        },
      });

      await expect(fetchVulnerabilitiesProductOwners(clientGroupId)).rejects.toThrow(
        'An unexpected error occurred'
      );
    });
  });

  describe('fetchVulnerabilitiesSpecialRelationships', () => {
    const clientGroupId = 50;

    it('should fetch all vulnerability records for special relationships in a client group', async () => {
      const mockVulnerabilityRecords = [
        createMockVulnerabilitySpecialRelationship({ id: 10, special_relationship_id: 200 }),
        createMockVulnerabilitySpecialRelationship({
          id: 11,
          special_relationship_id: 201,
          description: 'Language barrier',
        }),
      ];

      mockedApi.get.mockResolvedValueOnce({
        data: mockVulnerabilityRecords,
      });

      const result = await fetchVulnerabilitiesSpecialRelationships(clientGroupId);

      expect(mockedApi.get).toHaveBeenCalledWith('/vulnerabilities/special-relationships', {
        params: { client_group_id: clientGroupId },
      });
      expect(result).toEqual(mockVulnerabilityRecords);
      expect(result).toHaveLength(2);
    });

    it('should return empty array when no vulnerability records exist', async () => {
      mockedApi.get.mockResolvedValueOnce({
        data: [],
      });

      const result = await fetchVulnerabilitiesSpecialRelationships(clientGroupId);

      expect(result).toEqual([]);
    });
  });

  // ===========================================================================
  // VULNERABILITIES - CREATE
  // ===========================================================================
  describe('createVulnerability', () => {
    describe('for product owners', () => {
      it('should successfully create a vulnerability record for a product owner', async () => {
        const createData: VulnerabilityProductOwnerCreate = {
          product_owner_id: 100,
          description: 'Cognitive decline affecting financial decisions',
          adjustments: 'Speak slowly, provide written summaries',
          diagnosed: true,
          status: 'Active',
          notes: 'Family member should be present at meetings',
        };

        const mockCreatedRecord = createMockVulnerabilityProductOwner({
          id: 1,
          ...createData,
          created_at: '2025-01-09T10:00:00Z',
        });

        mockedApi.post.mockResolvedValueOnce({
          data: mockCreatedRecord,
        });

        const result = await createVulnerability(createData, 'product_owner');

        expect(mockedApi.post).toHaveBeenCalledWith('/vulnerabilities/product-owners', createData);
        expect(result.id).toBe(1);
        expect(result.description).toBe('Cognitive decline affecting financial decisions');
        expect(result.diagnosed).toBe(true);
      });

      it('should create a vulnerability record with minimal required fields', async () => {
        const minimalData: VulnerabilityProductOwnerCreate = {
          product_owner_id: 101,
          description: 'Visual impairment',
        };

        const mockCreatedRecord = createMockVulnerabilityProductOwner({
          id: 2,
          product_owner_id: 101,
          description: 'Visual impairment',
          adjustments: null,
          diagnosed: false,
          status: 'Active',
          notes: null,
        });

        mockedApi.post.mockResolvedValueOnce({
          data: mockCreatedRecord,
        });

        const result = await createVulnerability(minimalData, 'product_owner');

        expect(mockedApi.post).toHaveBeenCalledWith('/vulnerabilities/product-owners', minimalData);
        expect(result.id).toBe(2);
        expect(result.description).toBe('Visual impairment');
        expect(result.diagnosed).toBe(false);
      });

      it('should throw validation error when required fields are missing (422)', async () => {
        const invalidData = {
          product_owner_id: 100,
          // description is missing
        };

        mockedApi.post.mockRejectedValueOnce({
          response: {
            status: 422,
            data: {
              error: 'ValidationError',
              message: 'Request validation failed',
              details: {
                description: 'Description is required',
              },
            },
          },
        });

        await expect(
          createVulnerability(invalidData as VulnerabilityProductOwnerCreate, 'product_owner')
        ).rejects.toThrow('Request validation failed');
      });

      it('should throw error when product owner does not exist (404)', async () => {
        const createData: VulnerabilityProductOwnerCreate = {
          product_owner_id: 99999,
          description: 'Test vulnerability',
        };

        mockedApi.post.mockRejectedValueOnce({
          response: {
            status: 404,
            data: {
              error: 'NotFound',
              message: "Product owner with id '99999' not found",
            },
          },
        });

        await expect(createVulnerability(createData, 'product_owner')).rejects.toThrow(
          "Product owner with id '99999' not found"
        );
      });

      it('should throw error when description exceeds maximum length', async () => {
        const longDescription = 'x'.repeat(501); // VULNERABILITY_FIELD_LIMITS.description is 500

        const createData: VulnerabilityProductOwnerCreate = {
          product_owner_id: 100,
          description: longDescription,
        };

        mockedApi.post.mockRejectedValueOnce({
          response: {
            status: 422,
            data: {
              error: 'ValidationError',
              message: 'Request validation failed',
              details: {
                description: 'Description must not exceed 500 characters',
              },
            },
          },
        });

        await expect(createVulnerability(createData, 'product_owner')).rejects.toThrow(
          'Request validation failed'
        );
      });
    });

    describe('for special relationships', () => {
      it('should successfully create a vulnerability record for a special relationship', async () => {
        const createData: VulnerabilitySpecialRelationshipCreate = {
          special_relationship_id: 200,
          description: 'Recent bereavement affecting judgment',
          adjustments: 'Delay major financial decisions if possible',
          diagnosed: false,
          status: 'Monitoring',
          notes: 'Review in 6 months',
        };

        const mockCreatedRecord = createMockVulnerabilitySpecialRelationship({
          id: 10,
          ...createData,
          created_at: '2025-01-09T10:00:00Z',
        });

        mockedApi.post.mockResolvedValueOnce({
          data: mockCreatedRecord,
        });

        const result = await createVulnerability(createData, 'special_relationship');

        expect(mockedApi.post).toHaveBeenCalledWith(
          '/vulnerabilities/special-relationships',
          createData
        );
        expect(result.id).toBe(10);
        expect(result.description).toBe('Recent bereavement affecting judgment');
        expect(result.status).toBe('Monitoring');
      });

      it('should throw error when special relationship does not exist (404)', async () => {
        const createData: VulnerabilitySpecialRelationshipCreate = {
          special_relationship_id: 99999,
          description: 'Test vulnerability',
        };

        mockedApi.post.mockRejectedValueOnce({
          response: {
            status: 404,
            data: {
              error: 'NotFound',
              message: "Special relationship with id '99999' not found",
            },
          },
        });

        await expect(createVulnerability(createData, 'special_relationship')).rejects.toThrow(
          "Special relationship with id '99999' not found"
        );
      });
    });
  });

  // ===========================================================================
  // VULNERABILITIES - UPDATE
  // ===========================================================================
  describe('updateVulnerability', () => {
    describe('for product owners', () => {
      const vulnerabilityId = 1;

      it('should successfully update a vulnerability record', async () => {
        const updateData: VulnerabilityUpdate = {
          status: 'Resolved',
          notes: 'Vulnerability has been addressed',
        };

        const mockUpdatedRecord = createMockVulnerabilityProductOwner({
          id: vulnerabilityId,
          status: 'Resolved',
          notes: 'Vulnerability has been addressed',
        });

        mockedApi.put.mockResolvedValueOnce({
          data: mockUpdatedRecord,
        });

        const result = await updateVulnerability(vulnerabilityId, updateData, 'product_owner');

        expect(mockedApi.put).toHaveBeenCalledWith(
          `/vulnerabilities/product-owners/${vulnerabilityId}`,
          updateData
        );
        expect(result.status).toBe('Resolved');
        expect(result.notes).toBe('Vulnerability has been addressed');
      });

      it('should update only specified fields (partial update)', async () => {
        const updateData: VulnerabilityUpdate = {
          diagnosed: true,
        };

        const mockUpdatedRecord = createMockVulnerabilityProductOwner({
          id: vulnerabilityId,
          diagnosed: true,
        });

        mockedApi.put.mockResolvedValueOnce({
          data: mockUpdatedRecord,
        });

        const result = await updateVulnerability(vulnerabilityId, updateData, 'product_owner');

        expect(mockedApi.put).toHaveBeenCalledWith(
          `/vulnerabilities/product-owners/${vulnerabilityId}`,
          updateData
        );
        expect(result.diagnosed).toBe(true);
      });

      it('should update adjustments field', async () => {
        const updateData: VulnerabilityUpdate = {
          adjustments: 'Updated: Provide audio assistance and large print documents',
        };

        const mockUpdatedRecord = createMockVulnerabilityProductOwner({
          id: vulnerabilityId,
          adjustments: 'Updated: Provide audio assistance and large print documents',
        });

        mockedApi.put.mockResolvedValueOnce({
          data: mockUpdatedRecord,
        });

        const result = await updateVulnerability(vulnerabilityId, updateData, 'product_owner');

        expect(result.adjustments).toBe(
          'Updated: Provide audio assistance and large print documents'
        );
      });

      it('should throw error when vulnerability record not found (404)', async () => {
        const updateData: VulnerabilityUpdate = {
          status: 'Resolved',
        };

        mockedApi.put.mockRejectedValueOnce({
          response: {
            status: 404,
            data: {
              error: 'NotFound',
              message: `Vulnerability record with id '${vulnerabilityId}' not found`,
            },
          },
        });

        await expect(
          updateVulnerability(vulnerabilityId, updateData, 'product_owner')
        ).rejects.toThrow(`Vulnerability record with id '${vulnerabilityId}' not found`);
      });

      it('should throw validation error on invalid status value', async () => {
        const updateData = {
          status: 'InvalidStatus',
        };

        mockedApi.put.mockRejectedValueOnce({
          response: {
            status: 422,
            data: {
              error: 'ValidationError',
              message: 'Request validation failed',
              details: {
                status: 'Status must be one of: Active, Resolved, Monitoring, Inactive',
              },
            },
          },
        });

        await expect(
          updateVulnerability(vulnerabilityId, updateData as VulnerabilityUpdate, 'product_owner')
        ).rejects.toThrow('Request validation failed');
      });

      it('should throw error on unauthorized access (401)', async () => {
        const updateData: VulnerabilityUpdate = {
          status: 'Resolved',
        };

        mockedApi.put.mockRejectedValueOnce({
          response: {
            status: 401,
            data: {
              error: 'Unauthorized',
              message: 'Authentication credentials were not provided or are invalid',
            },
          },
        });

        await expect(
          updateVulnerability(vulnerabilityId, updateData, 'product_owner')
        ).rejects.toThrow('Authentication credentials were not provided or are invalid');
      });
    });

    describe('for special relationships', () => {
      const vulnerabilityId = 10;

      it('should successfully update a vulnerability record for special relationship', async () => {
        const updateData: VulnerabilityUpdate = {
          status: 'Inactive',
          notes: 'Vulnerability is no longer relevant',
        };

        const mockUpdatedRecord = createMockVulnerabilitySpecialRelationship({
          id: vulnerabilityId,
          status: 'Inactive',
          notes: 'Vulnerability is no longer relevant',
        });

        mockedApi.put.mockResolvedValueOnce({
          data: mockUpdatedRecord,
        });

        const result = await updateVulnerability(
          vulnerabilityId,
          updateData,
          'special_relationship'
        );

        expect(mockedApi.put).toHaveBeenCalledWith(
          `/vulnerabilities/special-relationships/${vulnerabilityId}`,
          updateData
        );
        expect(result.status).toBe('Inactive');
      });
    });
  });

  // ===========================================================================
  // VULNERABILITIES - DELETE
  // ===========================================================================
  describe('deleteVulnerability', () => {
    describe('for product owners', () => {
      const vulnerabilityId = 1;

      it('should successfully delete a vulnerability record', async () => {
        mockedApi.delete.mockResolvedValueOnce({
          status: 204,
          data: null,
        });

        await deleteVulnerability(vulnerabilityId, 'product_owner');

        expect(mockedApi.delete).toHaveBeenCalledWith(
          `/vulnerabilities/product-owners/${vulnerabilityId}`
        );
      });

      it('should throw error when vulnerability record not found (404)', async () => {
        mockedApi.delete.mockRejectedValueOnce({
          response: {
            status: 404,
            data: {
              error: 'NotFound',
              message: `Vulnerability record with id '${vulnerabilityId}' not found`,
            },
          },
        });

        await expect(deleteVulnerability(vulnerabilityId, 'product_owner')).rejects.toThrow(
          `Vulnerability record with id '${vulnerabilityId}' not found`
        );
      });

      it('should throw error on unauthorized access (401)', async () => {
        mockedApi.delete.mockRejectedValueOnce({
          response: {
            status: 401,
            data: {
              error: 'Unauthorized',
              message: 'Authentication credentials were not provided or are invalid',
            },
          },
        });

        await expect(deleteVulnerability(vulnerabilityId, 'product_owner')).rejects.toThrow(
          'Authentication credentials were not provided or are invalid'
        );
      });

      it('should throw error on server failure (500)', async () => {
        mockedApi.delete.mockRejectedValueOnce({
          response: {
            status: 500,
            data: {
              error: 'InternalServerError',
              message: 'An unexpected error occurred. Please try again later.',
            },
          },
        });

        await expect(deleteVulnerability(vulnerabilityId, 'product_owner')).rejects.toThrow(
          'An unexpected error occurred'
        );
      });
    });

    describe('for special relationships', () => {
      const vulnerabilityId = 10;

      it('should successfully delete a vulnerability record for special relationship', async () => {
        mockedApi.delete.mockResolvedValueOnce({
          status: 204,
          data: null,
        });

        await deleteVulnerability(vulnerabilityId, 'special_relationship');

        expect(mockedApi.delete).toHaveBeenCalledWith(
          `/vulnerabilities/special-relationships/${vulnerabilityId}`
        );
      });
    });
  });

  // ===========================================================================
  // EDGE CASES AND ERROR HANDLING
  // ===========================================================================
  describe('Edge Cases', () => {
    it('should handle network timeout errors gracefully', async () => {
      mockedApi.get.mockRejectedValueOnce({
        code: 'ECONNABORTED',
        message: 'timeout of 5000ms exceeded',
      });

      await expect(fetchHealthProductOwners(50)).rejects.toThrow();
    });

    it('should handle network connection errors gracefully', async () => {
      mockedApi.get.mockRejectedValueOnce({
        code: 'ENOTFOUND',
        message: 'Network Error',
      });

      await expect(fetchHealthProductOwners(50)).rejects.toThrow();
    });

    it('should handle malformed response data', async () => {
      mockedApi.get.mockResolvedValueOnce({
        data: null,
      });

      // The API service should handle null data gracefully
      const result = await fetchHealthProductOwners(50);
      expect(result).toBeNull();
    });

    it('should correctly route based on person type for create operations', async () => {
      const productOwnerData: HealthProductOwnerCreate = {
        product_owner_id: 100,
        condition: 'Test',
      };

      const specialRelData: HealthSpecialRelationshipCreate = {
        special_relationship_id: 200,
        condition: 'Test',
      };

      mockedApi.post.mockResolvedValue({ data: {} });

      await createHealthRecord(productOwnerData, 'product_owner');
      expect(mockedApi.post).toHaveBeenLastCalledWith('/health/product-owners', productOwnerData);

      await createHealthRecord(specialRelData, 'special_relationship');
      expect(mockedApi.post).toHaveBeenLastCalledWith(
        '/health/special-relationships',
        specialRelData
      );
    });

    it('should correctly route based on person type for update operations', async () => {
      const updateData: HealthConditionUpdate = { status: 'Active' };

      mockedApi.put.mockResolvedValue({ data: {} });

      await updateHealthRecord(1, updateData, 'product_owner');
      expect(mockedApi.put).toHaveBeenLastCalledWith('/health/product-owners/1', updateData);

      await updateHealthRecord(10, updateData, 'special_relationship');
      expect(mockedApi.put).toHaveBeenLastCalledWith(
        '/health/special-relationships/10',
        updateData
      );
    });

    it('should correctly route based on person type for delete operations', async () => {
      mockedApi.delete.mockResolvedValue({ status: 204, data: null });

      await deleteHealthRecord(1, 'product_owner');
      expect(mockedApi.delete).toHaveBeenLastCalledWith('/health/product-owners/1');

      await deleteHealthRecord(10, 'special_relationship');
      expect(mockedApi.delete).toHaveBeenLastCalledWith('/health/special-relationships/10');
    });
  });

  // ===========================================================================
  // VALIDATION FUNCTIONS
  // ===========================================================================
  describe('validateHealthData', () => {
    it('should return valid for correct health data', () => {
      const data = {
        product_owner_id: 100,
        condition: 'Diabetes',
        name: 'Type 2 Diabetes',
        medication: 'Metformin',
        notes: 'Monitor regularly',
        date_of_diagnosis: '2020-01-15',
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should return error for missing condition', () => {
      const data = {
        product_owner_id: 100,
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].field).toBe('condition');
      expect(result.errors[0].message).toBe('Condition is required');
    });

    it('should return error for empty condition', () => {
      const data = {
        product_owner_id: 100,
        condition: '   ',
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'condition')).toBe(true);
    });

    it('should return error for condition exceeding max length', () => {
      const data = {
        product_owner_id: 100,
        condition: 'x'.repeat(256), // Max is 255
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'condition' && e.message.includes('255'))).toBe(true);
    });

    it('should return error for name exceeding max length', () => {
      const data = {
        product_owner_id: 100,
        condition: 'Diabetes',
        name: 'x'.repeat(256), // Max is 255
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'name' && e.message.includes('255'))).toBe(true);
    });

    it('should return error for medication exceeding max length', () => {
      const data = {
        product_owner_id: 100,
        condition: 'Diabetes',
        medication: 'x'.repeat(501), // Max is 500
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'medication' && e.message.includes('500'))).toBe(true);
    });

    it('should return error for notes exceeding max length', () => {
      const data = {
        product_owner_id: 100,
        condition: 'Diabetes',
        notes: 'x'.repeat(2001), // Max is 2000
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'notes' && e.message.includes('2000'))).toBe(true);
    });

    it('should return error for future diagnosis date', () => {
      const futureDate = new Date();
      futureDate.setFullYear(futureDate.getFullYear() + 1);
      const futureDateString = futureDate.toISOString().split('T')[0];

      const data = {
        product_owner_id: 100,
        condition: 'Diabetes',
        date_of_diagnosis: futureDateString,
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'date_of_diagnosis')).toBe(true);
    });

    it('should allow past diagnosis date', () => {
      const data = {
        product_owner_id: 100,
        condition: 'Diabetes',
        date_of_diagnosis: '2020-01-15',
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(true);
    });

    it('should return multiple errors when multiple fields are invalid', () => {
      const futureDate = new Date();
      futureDate.setFullYear(futureDate.getFullYear() + 1);

      const data = {
        product_owner_id: 100,
        condition: '', // Invalid - empty
        name: 'x'.repeat(300), // Invalid - too long
        date_of_diagnosis: futureDate.toISOString().split('T')[0], // Invalid - future
      };

      const result = validateHealthData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.length).toBeGreaterThanOrEqual(3);
    });
  });

  describe('validateVulnerabilityData', () => {
    it('should return valid for correct vulnerability data', () => {
      const data = {
        product_owner_id: 100,
        description: 'Cognitive decline',
        adjustments: 'Speak slowly',
        notes: 'Review quarterly',
      };

      const result = validateVulnerabilityData(data);

      expect(result.isValid).toBe(true);
      expect(result.errors).toHaveLength(0);
    });

    it('should return error for missing description', () => {
      const data = {
        product_owner_id: 100,
      };

      const result = validateVulnerabilityData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors).toHaveLength(1);
      expect(result.errors[0].field).toBe('description');
      expect(result.errors[0].message).toBe('Description is required');
    });

    it('should return error for empty description', () => {
      const data = {
        product_owner_id: 100,
        description: '   ',
      };

      const result = validateVulnerabilityData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'description')).toBe(true);
    });

    it('should return error for description exceeding max length', () => {
      const data = {
        product_owner_id: 100,
        description: 'x'.repeat(501), // Max is 500
      };

      const result = validateVulnerabilityData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'description' && e.message.includes('500'))).toBe(true);
    });

    it('should return error for adjustments exceeding max length', () => {
      const data = {
        product_owner_id: 100,
        description: 'Valid description',
        adjustments: 'x'.repeat(1001), // Max is 1000
      };

      const result = validateVulnerabilityData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'adjustments' && e.message.includes('1000'))).toBe(true);
    });

    it('should return error for notes exceeding max length', () => {
      const data = {
        product_owner_id: 100,
        description: 'Valid description',
        notes: 'x'.repeat(2001), // Max is 2000
      };

      const result = validateVulnerabilityData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.some(e => e.field === 'notes' && e.message.includes('2000'))).toBe(true);
    });

    it('should return multiple errors when multiple fields are invalid', () => {
      const data = {
        product_owner_id: 100,
        description: '', // Invalid - empty
        adjustments: 'x'.repeat(1100), // Invalid - too long
        notes: 'x'.repeat(2100), // Invalid - too long
      };

      const result = validateVulnerabilityData(data);

      expect(result.isValid).toBe(false);
      expect(result.errors.length).toBeGreaterThanOrEqual(3);
    });
  });

  // ===========================================================================
  // USER-FRIENDLY ERROR MESSAGES
  // ===========================================================================
  describe('getUserFriendlyErrorMessage', () => {
    it('should return message from response data if available', () => {
      const error = {
        response: {
          status: 400,
          data: {
            message: 'Custom error message from server',
          },
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('Custom error message from server');
    });

    it('should return detail from response data if message not available', () => {
      const error = {
        response: {
          status: 422,
          data: {
            detail: 'Validation failed for field X',
          },
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('Validation failed for field X');
    });

    it('should return standard message for 400 status', () => {
      const error = {
        response: {
          status: 400,
          data: {},
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('The request contains invalid data. Please check your input.');
    });

    it('should return standard message for 401 status', () => {
      const error = {
        response: {
          status: 401,
          data: {},
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('Your session has expired. Please log in again.');
    });

    it('should return standard message for 403 status', () => {
      const error = {
        response: {
          status: 403,
          data: {},
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('You do not have permission to perform this action.');
    });

    it('should return standard message for 404 status', () => {
      const error = {
        response: {
          status: 404,
          data: {},
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('The requested record was not found.');
    });

    it('should return standard message for 422 status', () => {
      const error = {
        response: {
          status: 422,
          data: {},
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('The provided data is invalid. Please check the required fields.');
    });

    it('should return standard message for 500 status', () => {
      const error = {
        response: {
          status: 500,
          data: {},
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('An unexpected error occurred. Please try again later.');
    });

    it('should return generic message for unknown status codes', () => {
      const error = {
        response: {
          status: 418, // I'm a teapot
          data: {},
        },
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('An error occurred (418). Please try again.');
    });

    it('should return network error message for ERR_NETWORK code', () => {
      const error = {
        code: 'ERR_NETWORK',
        message: 'Network Error',
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('Unable to connect to the server. Please check your internet connection.');
    });

    it('should return timeout error message for ECONNABORTED code', () => {
      const error = {
        code: 'ECONNABORTED',
        message: 'timeout of 5000ms exceeded',
      };

      const result = getUserFriendlyErrorMessage(error);

      expect(result).toBe('The request took too long. Please try again.');
    });

    it('should return default message for non-object errors', () => {
      const result = getUserFriendlyErrorMessage('string error');

      expect(result).toBe('An unexpected error occurred. Please try again.');
    });

    it('should return default message for null', () => {
      const result = getUserFriendlyErrorMessage(null);

      expect(result).toBe('An unexpected error occurred. Please try again.');
    });

    it('should return default message for undefined', () => {
      const result = getUserFriendlyErrorMessage(undefined);

      expect(result).toBe('An unexpected error occurred. Please try again.');
    });
  });

  // ===========================================================================
  // DEBOUNCE UTILITY
  // ===========================================================================
  describe('debounce', () => {
    beforeEach(() => {
      jest.useFakeTimers();
    });

    afterEach(() => {
      jest.useRealTimers();
    });

    it('should delay function execution', () => {
      const mockFn = jest.fn();
      const debouncedFn = debounce(mockFn, 300);

      debouncedFn('test');

      expect(mockFn).not.toHaveBeenCalled();

      jest.advanceTimersByTime(300);

      expect(mockFn).toHaveBeenCalledTimes(1);
      expect(mockFn).toHaveBeenCalledWith('test');
    });

    it('should cancel previous call when called again within delay', () => {
      const mockFn = jest.fn();
      const debouncedFn = debounce(mockFn, 300);

      debouncedFn('first');
      jest.advanceTimersByTime(100);

      debouncedFn('second');
      jest.advanceTimersByTime(100);

      debouncedFn('third');
      jest.advanceTimersByTime(300);

      expect(mockFn).toHaveBeenCalledTimes(1);
      expect(mockFn).toHaveBeenCalledWith('third');
    });

    it('should execute multiple times if delay passes between calls', () => {
      const mockFn = jest.fn();
      const debouncedFn = debounce(mockFn, 300);

      debouncedFn('first');
      jest.advanceTimersByTime(300);

      debouncedFn('second');
      jest.advanceTimersByTime(300);

      expect(mockFn).toHaveBeenCalledTimes(2);
      expect(mockFn).toHaveBeenNthCalledWith(1, 'first');
      expect(mockFn).toHaveBeenNthCalledWith(2, 'second');
    });

    it('should pass all arguments to the debounced function', () => {
      const mockFn = jest.fn();
      const debouncedFn = debounce(mockFn, 300);

      debouncedFn('arg1', 'arg2', { key: 'value' });
      jest.advanceTimersByTime(300);

      expect(mockFn).toHaveBeenCalledWith('arg1', 'arg2', { key: 'value' });
    });

    it('should work with zero delay', () => {
      const mockFn = jest.fn();
      const debouncedFn = debounce(mockFn, 0);

      debouncedFn('test');
      jest.advanceTimersByTime(0);

      expect(mockFn).toHaveBeenCalledTimes(1);
    });
  });
});
