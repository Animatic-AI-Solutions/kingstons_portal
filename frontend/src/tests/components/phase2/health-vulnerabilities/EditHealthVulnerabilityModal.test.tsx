/**
 * EditHealthVulnerabilityModal Component Tests (RED Phase - Cycle 10.5)
 *
 * Tests for the EditHealthVulnerabilityModal component that provides a modal dialog
 * for editing existing health conditions or vulnerabilities for a person.
 *
 * The component displays different form fields based on tabType:
 * - Health form: condition dropdown, name, date_of_diagnosis, medication, status, notes
 * - Vulnerability form: description, adjustments, diagnosed checkbox, status, notes
 *
 * Following TDD RED-GREEN-BLUE methodology.
 * Expected Result: All tests FAIL (RED phase) until implementation complete.
 *
 * @module tests/components/phase2/health-vulnerabilities/EditHealthVulnerabilityModal
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { axe, toHaveNoViolations } from 'jest-axe';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import type {
  PersonWithCounts,
  HealthCondition,
  Vulnerability,
  HealthProductOwner,
  VulnerabilityProductOwner,
  HealthSpecialRelationship,
  VulnerabilitySpecialRelationship,
} from '@/types/healthVulnerability';

// This import will fail in RED phase - component doesn't exist yet
import EditHealthVulnerabilityModal from '@/components/phase2/health-vulnerabilities/EditHealthVulnerabilityModal';

// Extend Jest matchers with jest-axe
expect.extend(toHaveNoViolations);

// =============================================================================
// Mock Setup
// =============================================================================

// Mock the health/vulnerability hooks
const mockUpdateHealthRecord = jest.fn();
const mockUpdateVulnerability = jest.fn();

jest.mock('@/hooks/useHealthVulnerabilities', () => ({
  useUpdateHealthRecord: jest.fn(() => ({
    mutateAsync: mockUpdateHealthRecord,
    isPending: false,
  })),
  useUpdateVulnerability: jest.fn(() => ({
    mutateAsync: mockUpdateVulnerability,
    isPending: false,
  })),
}));

// =============================================================================
// Mock Data
// =============================================================================

const mockPerson: PersonWithCounts = {
  id: 1,
  name: 'John Smith',
  relationship: 'Primary Owner',
  personType: 'product_owner',
  status: 'Active',
  activeCount: 2,
  inactiveCount: 0,
};

const mockSpecialRelationshipPerson: PersonWithCounts = {
  id: 10,
  name: 'Jane Doe',
  relationship: 'Spouse',
  personType: 'special_relationship',
  status: 'Active',
  activeCount: 2,
  inactiveCount: 1,
};

const mockHealthCondition: HealthProductOwner = {
  id: 101,
  product_owner_id: 1,
  condition: 'Other',
  name: 'Heart Condition',
  date_of_diagnosis: '2020-01-15',
  status: 'Active',
  medication: 'Metformin 500mg',
  date_recorded: '2024-01-01T00:00:00Z',
  notes: 'Well controlled',
  created_at: '2024-01-01T00:00:00Z',
};

const mockHealthConditionNoOptionals: HealthProductOwner = {
  id: 102,
  product_owner_id: 1,
  condition: 'Smoking Status',
  name: null,
  date_of_diagnosis: null,
  status: 'Active',
  medication: null,
  date_recorded: null,
  notes: null,
  created_at: '2024-01-01T00:00:00Z',
};

const mockVulnerability: VulnerabilityProductOwner = {
  id: 201,
  product_owner_id: 1,
  description: 'Hearing impairment',
  adjustments: 'Speak clearly, face-to-face',
  diagnosed: true,
  date_recorded: '2024-01-01T00:00:00Z',
  status: 'Active',
  notes: 'Uses hearing aid',
  created_at: '2024-01-01T00:00:00Z',
};

const mockVulnerabilityNoOptionals: VulnerabilityProductOwner = {
  id: 202,
  product_owner_id: 1,
  description: 'Cognitive decline',
  adjustments: null,
  diagnosed: false,
  date_recorded: null,
  status: 'Active',
  notes: null,
  created_at: '2024-01-01T00:00:00Z',
};

const mockSpecialRelationshipHealth: HealthSpecialRelationship = {
  id: 301,
  special_relationship_id: 10,
  condition: 'Heart Condition',
  name: 'Atrial Fibrillation',
  date_of_diagnosis: '2021-06-20',
  status: 'Active',
  medication: 'Warfarin 5mg',
  date_recorded: '2024-01-01T00:00:00Z',
  notes: 'Regular INR monitoring',
  created_at: '2024-01-01T00:00:00Z',
};

const mockSpecialRelationshipVulnerability: VulnerabilitySpecialRelationship = {
  id: 401,
  special_relationship_id: 10,
  description: 'Memory difficulties',
  adjustments: 'Write down key points',
  diagnosed: true,
  date_recorded: '2024-01-01T00:00:00Z',
  status: 'Active',
  notes: 'Diagnosed MCI',
  created_at: '2024-01-01T00:00:00Z',
};

// =============================================================================
// Test Utilities
// =============================================================================

/**
 * Creates a wrapper with QueryClient for React Query context
 */
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

/**
 * Default props for health edit modal
 */
const defaultHealthProps = {
  isOpen: true,
  onClose: jest.fn(),
  person: mockPerson,
  record: mockHealthCondition as HealthCondition,
  tabType: 'health' as const,
  onSuccess: jest.fn(),
};

/**
 * Default props for vulnerability edit modal
 */
const defaultVulnerabilityProps = {
  isOpen: true,
  onClose: jest.fn(),
  person: mockPerson,
  record: mockVulnerability as Vulnerability,
  tabType: 'vulnerabilities' as const,
  onSuccess: jest.fn(),
};

// =============================================================================
// Test Suite
// =============================================================================

describe('EditHealthVulnerabilityModal Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Reset mock implementations to default values (isPending: false)
    const mockHooks = require('@/hooks/useHealthVulnerabilities') as any;
    mockHooks.useUpdateHealthRecord.mockReturnValue({
      mutateAsync: mockUpdateHealthRecord,
      isPending: false,
    });
    mockHooks.useUpdateVulnerability.mockReturnValue({
      mutateAsync: mockUpdateVulnerability,
      isPending: false,
    });
    mockUpdateHealthRecord.mockResolvedValue({ id: 101 });
    mockUpdateVulnerability.mockResolvedValue({ id: 201 });
  });

  // ===========================================================================
  // 1. Modal Rendering Tests (5 tests)
  // ===========================================================================

  describe('Modal Rendering', () => {
    it('should not render when isOpen is false', () => {
      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          isOpen={false}
        />,
        { wrapper: createWrapper() }
      );

      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });

    it('should render when isOpen is true', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByRole('dialog')).toBeInTheDocument();
    });

    it('should show person name in title', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByText(/John Smith/i)).toBeInTheDocument();
    });

    it('should show "Edit Health Condition for {name}" when tabType is health', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(
        screen.getByRole('heading', { name: /edit health condition for john smith/i })
      ).toBeInTheDocument();
    });

    it('should show "Edit Vulnerability for {name}" when tabType is vulnerabilities', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      expect(
        screen.getByRole('heading', { name: /edit vulnerability for john smith/i })
      ).toBeInTheDocument();
    });
  });

  // ===========================================================================
  // 2. Health Form Pre-population Tests (5 tests)
  // ===========================================================================

  describe('Health Form Pre-population', () => {
    it('should pre-populate condition dropdown with existing value', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // ComboDropdown shows the selected value in the button text
      const conditionButton = screen.getByRole('combobox', { name: /condition/i });
      expect(conditionButton).toBeInTheDocument();
    });

    it('should pre-populate name field with existing value', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByDisplayValue('Heart Condition')).toBeInTheDocument();
    });

    it('should pre-populate medication field with existing value', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByDisplayValue('Metformin 500mg')).toBeInTheDocument();
    });

    it('should pre-populate date of diagnosis field with existing value', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByDisplayValue('2020-01-15')).toBeInTheDocument();
    });

    it('should pre-populate notes field with existing value', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByDisplayValue('Well controlled')).toBeInTheDocument();
    });
  });

  // ===========================================================================
  // 3. Vulnerability Form Pre-population Tests (5 tests)
  // ===========================================================================

  describe('Vulnerability Form Pre-population', () => {
    it('should pre-populate description field with existing value', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByDisplayValue('Hearing impairment')).toBeInTheDocument();
    });

    it('should pre-populate adjustments field with existing value', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByDisplayValue('Speak clearly, face-to-face')).toBeInTheDocument();
    });

    it('should pre-populate diagnosed checkbox with existing value (checked)', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const diagnosedCheckbox = screen.getByRole('checkbox', { name: /professionally diagnosed/i });
      expect(diagnosedCheckbox).toBeChecked();
    });

    it('should pre-populate diagnosed checkbox with existing value (unchecked)', () => {
      render(
        <EditHealthVulnerabilityModal
          {...defaultVulnerabilityProps}
          record={mockVulnerabilityNoOptionals as Vulnerability}
        />,
        { wrapper: createWrapper() }
      );

      const diagnosedCheckbox = screen.getByRole('checkbox', { name: /professionally diagnosed/i });
      expect(diagnosedCheckbox).not.toBeChecked();
    });

    it('should pre-populate notes field with existing value for vulnerability', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByDisplayValue('Uses hearing aid')).toBeInTheDocument();
    });
  });

  // ===========================================================================
  // 4. Modal Actions Tests (4 tests)
  // ===========================================================================

  describe('Modal Actions', () => {
    it('should call onClose when Cancel button is clicked', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      const cancelButton = screen.getByRole('button', { name: /cancel/i });
      await user.click(cancelButton);

      expect(mockOnClose).toHaveBeenCalledTimes(1);
    });

    it('should call onClose when X button is clicked', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      const closeButton = screen.getByRole('button', { name: /close/i });
      await user.click(closeButton);

      expect(mockOnClose).toHaveBeenCalledTimes(1);
    });

    it('should close modal on Escape key press', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      await user.keyboard('{Escape}');

      expect(mockOnClose).toHaveBeenCalledTimes(1);
    });

    it('should close modal on backdrop click', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      const backdrop = screen.getByTestId('modal-backdrop');
      await user.click(backdrop);

      expect(mockOnClose).toHaveBeenCalledTimes(1);
    });
  });

  // ===========================================================================
  // 5. Accessibility Tests (8 tests)
  // ===========================================================================

  describe('Accessibility', () => {
    it('should have no accessibility violations for health form (jest-axe)', async () => {
      const { container } = render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });

    it('should have no accessibility violations for vulnerability form (jest-axe)', async () => {
      const { container } = render(
        <EditHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });

    it('should trap focus within modal', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Verify modal has focusable elements for focus trap
      const modal = screen.getByRole('dialog');
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      // Modal should have focusable elements for focus trap to work
      expect(focusableElements.length).toBeGreaterThan(0);
      // Modal should be in the DOM (focus trap is handled by HeadlessUI Dialog)
      expect(modal).toBeInTheDocument();
    });

    it('should have aria-labelledby pointing to dialog title', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const dialog = screen.getByRole('dialog');
      const labelledBy = dialog.getAttribute('aria-labelledby');
      expect(labelledBy).toBeTruthy();

      // The element referenced by aria-labelledby should exist
      const titleElement = document.getElementById(labelledBy!);
      expect(titleElement).toBeInTheDocument();
      expect(titleElement).toHaveTextContent(/edit health condition/i);
    });

    it('should have aria-modal="true" on dialog', () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const dialog = screen.getByRole('dialog');
      expect(dialog).toHaveAttribute('aria-modal', 'true');
    });

    it('should show aria-live region when there is an announcement', () => {
      // The aria-live region only appears when there's an announcement (success/error)
      // Initially there is no live region, but one will appear on success or error
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Initially no aria-live region (empty div was removed for accessibility best practices)
      // Status region only appears when there's a message to announce
      // This is tested via the success and error submission tests
      const liveRegion = document.querySelector('[aria-live]');
      expect(liveRegion).not.toBeInTheDocument();
    });

    it('should focus cancel button on modal open', async () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      await waitFor(() => {
        const cancelButton = screen.getByRole('button', { name: /cancel/i });
        expect(cancelButton).toHaveFocus();
      });
    });

    it('should return focus to trigger element after modal closes', async () => {
      const user = userEvent.setup();
      const triggerRef = React.createRef<HTMLButtonElement>();

      const TestComponent = () => {
        const [isOpen, setIsOpen] = React.useState(false);
        return (
          <>
            <button ref={triggerRef} onClick={() => setIsOpen(true)}>
              Edit Record
            </button>
            <EditHealthVulnerabilityModal
              {...defaultHealthProps}
              isOpen={isOpen}
              onClose={() => setIsOpen(false)}
              triggerRef={triggerRef}
            />
          </>
        );
      };

      render(<TestComponent />, { wrapper: createWrapper() });

      // Open modal
      const openButton = screen.getByRole('button', { name: /edit record/i });
      await user.click(openButton);

      // Verify modal is open
      await waitFor(() => {
        expect(screen.getByRole('dialog')).toBeInTheDocument();
      });

      // Close modal with Escape
      await user.keyboard('{Escape}');

      // Focus should return to trigger
      await waitFor(() => {
        expect(document.activeElement).toBe(openButton);
      });
    });
  });

  // ===========================================================================
  // 6. Inline Validation Tests (4 tests)
  // ===========================================================================

  describe('Inline Validation', () => {
    it('should show error on blur when condition is cleared', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Select empty option to clear condition and blur to trigger validation
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, '');
      fireEvent.blur(conditionSelect);

      await waitFor(() => {
        expect(screen.getByText(/condition is required/i)).toBeInTheDocument();
      });
    });

    it('should clear error when valid value entered', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Select empty option to clear condition and blur to trigger validation
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, '');
      fireEvent.blur(conditionSelect);

      await waitFor(() => {
        expect(screen.getByText(/condition is required/i)).toBeInTheDocument();
      });

      // Enter valid value - error should clear (reuse existing conditionSelect)
      await user.selectOptions(conditionSelect, 'Smoking Status');

      await waitFor(() => {
        expect(screen.queryByText(/condition is required/i)).not.toBeInTheDocument();
      });
    });

    it('should apply error styling (border-red) to invalid field', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Select empty option to clear condition and blur to trigger validation
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, '');
      fireEvent.blur(conditionSelect);

      await waitFor(() => {
        const clearedSelect = screen.getByRole('combobox', { name: /condition/i });
        expect(clearedSelect).toHaveClass('border-red-300');
      });
    });

    it('should validate vulnerability description on blur when cleared', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const descriptionInput = screen.getByLabelText(/description/i);

      // Clear the input
      await user.clear(descriptionInput);
      fireEvent.blur(descriptionInput);

      await waitFor(() => {
        expect(screen.getByText(/description is required/i)).toBeInTheDocument();
      });
    });
  });

  // ===========================================================================
  // 7. Edge Cases Tests (5 tests)
  // ===========================================================================

  describe('Edge Cases', () => {
    it('should reset form when closed and reopened with same record', async () => {
      const user = userEvent.setup();

      const TestComponent = () => {
        const [isOpen, setIsOpen] = React.useState(true);
        return (
          <>
            <button onClick={() => setIsOpen(true)}>Reopen</button>
            <EditHealthVulnerabilityModal
              {...defaultHealthProps}
              isOpen={isOpen}
              onClose={() => setIsOpen(false)}
            />
          </>
        );
      };

      render(<TestComponent />, { wrapper: createWrapper() });

      // Change medication
      const medicationInput = screen.getByLabelText(/medication/i);
      await user.clear(medicationInput);
      await user.type(medicationInput, 'New medication');

      expect(medicationInput).toHaveValue('New medication');

      // Close modal
      const cancelButton = screen.getByRole('button', { name: /cancel/i });
      await user.click(cancelButton);

      // Reopen modal
      const reopenButton = screen.getByRole('button', { name: /reopen/i });
      await user.click(reopenButton);

      // Form should be reset to original values
      await waitFor(() => {
        const newMedicationInput = screen.getByLabelText(/medication/i);
        expect(newMedicationInput).toHaveValue('Metformin 500mg');
      });
    });

    it('should handle special characters in input', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const notesField = screen.getByLabelText(/notes/i);
      await user.clear(notesField);
      await user.type(notesField, "O'Brien's condition - <test> & \"special\" chars");

      expect(notesField).toHaveValue("O'Brien's condition - <test> & \"special\" chars");
    });

    it('should handle unicode characters', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const notesField = screen.getByLabelText(/notes/i);
      await user.clear(notesField);
      await user.type(notesField, '\u8A8D\u77E5\u969C\u5BB3 - \u8A8D\u77E5\u75C7');

      expect(notesField).toHaveValue('\u8A8D\u77E5\u969C\u5BB3 - \u8A8D\u77E5\u75C7');
    });

    it('should handle long text in notes field', () => {
      const longText = 'A'.repeat(2000);

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const notesField = screen.getByLabelText(/notes/i);
      // Use fireEvent.change for performance with long text
      fireEvent.change(notesField, { target: { value: longText } });

      expect(notesField).toHaveValue(longText);
      // Modal should not overflow or break
      expect(screen.getByRole('dialog')).toBeVisible();
    });

    it('should handle record with null optional fields', () => {
      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          record={mockHealthConditionNoOptionals as HealthCondition}
        />,
        { wrapper: createWrapper() }
      );

      // Should render without errors
      expect(screen.getByRole('dialog')).toBeInTheDocument();

      // Optional fields should be empty strings, not "null"
      expect(screen.queryByDisplayValue('null')).not.toBeInTheDocument();

      // Name field should be empty
      const nameField = screen.getByLabelText(/^name$/i);
      expect(nameField).toHaveValue('');
    });
  });

  // ===========================================================================
  // 8. Keyboard Navigation Tests (2 tests)
  // ===========================================================================

  describe('Keyboard Navigation', () => {
    it('should allow Tab navigation through form fields', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const modal = screen.getByRole('dialog');

      // Verify modal contains focusable form elements for tab navigation
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      // Should have multiple focusable elements (form fields + buttons)
      expect(focusableElements.length).toBeGreaterThan(5);

      // Start at cancel button (initial focus)
      await waitFor(() => {
        expect(screen.getByRole('button', { name: /cancel/i })).toHaveFocus();
      });

      // Tab through form elements - should be able to reach save button
      const saveButton = screen.getByRole('button', { name: /save/i });
      let maxTabs = 15;
      while (!saveButton.matches(':focus') && maxTabs > 0) {
        await user.tab();
        maxTabs--;
      }

      // Save should be reachable via tab navigation
      expect(maxTabs).toBeGreaterThan(0);
    });

    it('should submit form on Enter when focus is on submit button', async () => {
      const user = userEvent.setup();
      const mockOnSuccess = jest.fn();

      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          onSuccess={mockOnSuccess}
        />,
        { wrapper: createWrapper() }
      );

      // Focus submit button and press Enter
      const submitButton = screen.getByRole('button', { name: /save/i });
      submitButton.focus();
      await user.keyboard('{Enter}');

      await waitFor(() => {
        expect(mockUpdateHealthRecord).toHaveBeenCalled();
      });
    });
  });

  // ===========================================================================
  // 9. Form Submission Tests (3 tests)
  // ===========================================================================

  describe('Form Submission', () => {
    it('should call useUpdateHealthRecord mutation with updated data', async () => {
      const user = userEvent.setup();
      const mockOnSuccess = jest.fn();

      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          onSuccess={mockOnSuccess}
        />,
        { wrapper: createWrapper() }
      );

      // Change medication field
      const medicationInput = screen.getByLabelText(/medication/i);
      await user.clear(medicationInput);
      await user.type(medicationInput, 'Metformin 1000mg');

      // Change status
      const statusSelect = screen.getByLabelText(/status/i);
      await user.selectOptions(statusSelect, 'Inactive');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockUpdateHealthRecord).toHaveBeenCalledWith(
          expect.objectContaining({
            id: 101,
            data: expect.objectContaining({
              medication: 'Metformin 1000mg',
              status: 'Inactive',
            }),
            personType: 'product_owner',
          })
        );
        expect(mockOnSuccess).toHaveBeenCalled();
      });
    });

    it('should call useUpdateVulnerability mutation with updated data', async () => {
      const user = userEvent.setup();
      const mockOnSuccess = jest.fn();

      render(
        <EditHealthVulnerabilityModal
          {...defaultVulnerabilityProps}
          onSuccess={mockOnSuccess}
        />,
        { wrapper: createWrapper() }
      );

      // Update description
      const descriptionInput = screen.getByLabelText(/description/i);
      await user.clear(descriptionInput);
      await user.type(descriptionInput, 'Severe hearing impairment');

      // Toggle diagnosed checkbox (currently checked, should uncheck)
      const diagnosedCheckbox = screen.getByRole('checkbox', { name: /professionally diagnosed/i });
      await user.click(diagnosedCheckbox);

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockUpdateVulnerability).toHaveBeenCalledWith(
          expect.objectContaining({
            id: 201,
            data: expect.objectContaining({
              description: 'Severe hearing impairment',
              diagnosed: false,
            }),
            personType: 'product_owner',
          })
        );
        expect(mockOnSuccess).toHaveBeenCalled();
      });
    });

    it('should disable submit button and show loading state while submitting', async () => {
      const user = userEvent.setup();

      // Mock the hook to return isPending: true
      const { useUpdateHealthRecord } = jest.requireMock('@/hooks/useHealthVulnerabilities');
      useUpdateHealthRecord.mockReturnValue({
        mutateAsync: mockUpdateHealthRecord,
        isPending: true,
      });

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const submitButton = screen.getByRole('button', { name: /saving|loading/i });
      expect(submitButton).toBeDisabled();
    });
  });

  // ===========================================================================
  // 10. Error Handling Tests (2 tests)
  // ===========================================================================

  describe('Error Handling', () => {
    it('should display error message when API call fails', async () => {
      const user = userEvent.setup();
      mockUpdateHealthRecord.mockRejectedValue(new Error('Network error'));

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/error|failed/i)).toBeInTheDocument();
      });
    });

    it('should not call onSuccess or close modal when API call fails', async () => {
      const user = userEvent.setup();
      const mockOnSuccess = jest.fn();
      const mockOnClose = jest.fn();
      mockUpdateHealthRecord.mockRejectedValue(new Error('Server error'));

      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          onSuccess={mockOnSuccess}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockUpdateHealthRecord).toHaveBeenCalled();
      });

      // onSuccess should not be called on error
      expect(mockOnSuccess).not.toHaveBeenCalled();
      // Modal should remain open (onClose not called due to error)
      expect(screen.getByRole('dialog')).toBeInTheDocument();
    });
  });

  // ===========================================================================
  // 11. Special Relationship Support Tests (3 tests)
  // ===========================================================================

  describe('Special Relationship Support', () => {
    it('should handle special relationship person for health condition', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          person={mockSpecialRelationshipPerson}
          record={mockSpecialRelationshipHealth as HealthCondition}
        />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByRole('dialog')).toBeInTheDocument();
      expect(screen.getByText(/Jane Doe/i)).toBeInTheDocument();

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockUpdateHealthRecord).toHaveBeenCalledWith(
          expect.objectContaining({
            id: 301,
            personType: 'special_relationship',
          })
        );
      });
    });

    it('should handle special relationship person for vulnerability', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal
          {...defaultVulnerabilityProps}
          person={mockSpecialRelationshipPerson}
          record={mockSpecialRelationshipVulnerability as Vulnerability}
        />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByRole('dialog')).toBeInTheDocument();
      expect(screen.getByText(/Jane Doe/i)).toBeInTheDocument();

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockUpdateVulnerability).toHaveBeenCalledWith(
          expect.objectContaining({
            id: 401,
            personType: 'special_relationship',
          })
        );
      });
    });

    it('should pre-populate special relationship health record correctly', () => {
      render(
        <EditHealthVulnerabilityModal
          {...defaultHealthProps}
          person={mockSpecialRelationshipPerson}
          record={mockSpecialRelationshipHealth as HealthCondition}
        />,
        { wrapper: createWrapper() }
      );

      // Check pre-populated values
      expect(screen.getByDisplayValue('Atrial Fibrillation')).toBeInTheDocument();
      expect(screen.getByDisplayValue('Warfarin 5mg')).toBeInTheDocument();
      expect(screen.getByDisplayValue('Regular INR monitoring')).toBeInTheDocument();
    });
  });

  // ===========================================================================
  // 12. Form Field Updates Tests (4 tests)
  // ===========================================================================

  describe('Form Field Updates', () => {
    it('should allow changing condition selection in health form', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Get the condition select element
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      expect(conditionSelect).toBeInTheDocument();

      // Change selection to Smoking Status
      await user.selectOptions(conditionSelect, 'Smoking Status');

      // Verify new selection
      expect(conditionSelect).toHaveValue('Smoking Status');
    });

    it('should allow toggling diagnosed checkbox in vulnerability form', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const diagnosedCheckbox = screen.getByRole('checkbox', { name: /professionally diagnosed/i });

      // Original value is checked
      expect(diagnosedCheckbox).toBeChecked();

      await user.click(diagnosedCheckbox);
      expect(diagnosedCheckbox).not.toBeChecked();

      await user.click(diagnosedCheckbox);
      expect(diagnosedCheckbox).toBeChecked();
    });

    it('should allow changing status in health form', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const statusSelect = screen.getByLabelText(/status/i);

      // Default should be Active
      expect(statusSelect).toHaveValue('Active');

      // Change to Lapsed
      await user.selectOptions(statusSelect, 'Inactive');
      expect(statusSelect).toHaveValue('Inactive');
    });

    it('should allow editing date of diagnosis', async () => {
      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const dateInput = screen.getByLabelText(/diagnosed/i);
      expect(dateInput).toHaveValue('2020-01-15');

      fireEvent.change(dateInput, { target: { value: '2022-06-30' } });

      expect(dateInput).toHaveValue('2022-06-30');
    });
  });

  // ===========================================================================
  // 13. Aria-live Announcements Tests (2 tests)
  // ===========================================================================

  describe('Aria-live Announcements', () => {
    it('should announce success via aria-live on successful update', async () => {
      const user = userEvent.setup();

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      await waitFor(() => {
        const liveRegion = document.querySelector('[aria-live="polite"]');
        expect(liveRegion).toHaveTextContent(/updated successfully|saved/i);
      });
    });

    it('should announce error via aria-live assertive on failure', async () => {
      const user = userEvent.setup();
      mockUpdateHealthRecord.mockRejectedValue(new Error('Server error'));

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      await waitFor(() => {
        const alertRegion = screen.getByRole('alert');
        expect(alertRegion).toHaveAttribute('aria-live', 'assertive');
        expect(alertRegion).toHaveTextContent(/error|failed/i);
      });
    });
  });

  // ===========================================================================
  // 14. Focus Return on Success Tests (1 test)
  // ===========================================================================

  describe('Focus Return on Success', () => {
    it('should return focus to trigger after successful update', async () => {
      const user = userEvent.setup();
      const triggerRef = React.createRef<HTMLButtonElement>();

      const TestComponent = () => {
        const [isOpen, setIsOpen] = React.useState(false);
        return (
          <>
            <button ref={triggerRef} onClick={() => setIsOpen(true)}>
              Edit Record
            </button>
            <EditHealthVulnerabilityModal
              {...defaultHealthProps}
              isOpen={isOpen}
              onClose={() => setIsOpen(false)}
              onSuccess={() => setIsOpen(false)}
              triggerRef={triggerRef}
            />
          </>
        );
      };

      render(<TestComponent />, { wrapper: createWrapper() });

      // Open modal
      const openButton = screen.getByRole('button', { name: /edit record/i });
      await user.click(openButton);

      // Verify modal is open
      await waitFor(() => {
        expect(screen.getByRole('dialog')).toBeInTheDocument();
      });

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save/i });
      await user.click(submitButton);

      // Wait for success and modal close
      await waitFor(() => {
        expect(mockUpdateHealthRecord).toHaveBeenCalled();
      });

      // Focus should return to trigger
      await waitFor(() => {
        expect(document.activeElement).toBe(openButton);
      });
    });
  });

  // ===========================================================================
  // 15. Double Submission Prevention Test (1 test)
  // ===========================================================================

  describe('Double Submission Prevention', () => {
    it('should prevent double submission by disabling button during submit', async () => {
      const user = userEvent.setup();

      // Make the mutation hang to simulate in-progress state
      mockUpdateHealthRecord.mockImplementation(
        () => new Promise(resolve => setTimeout(() => resolve({ id: 101 }), 1000))
      );

      // Re-mock the hook to return isPending: true after first call
      const { useUpdateHealthRecord } = jest.requireMock('@/hooks/useHealthVulnerabilities');
      useUpdateHealthRecord.mockReturnValue({
        mutateAsync: mockUpdateHealthRecord,
        isPending: true,
      });

      render(
        <EditHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Submit button should be disabled when isPending is true
      const submitButton = screen.getByRole('button', { name: /save|saving/i });
      expect(submitButton).toBeDisabled();
    });
  });
});
