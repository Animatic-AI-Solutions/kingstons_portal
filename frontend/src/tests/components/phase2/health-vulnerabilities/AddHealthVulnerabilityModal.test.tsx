/**
 * AddHealthVulnerabilityModal Component Tests (RED Phase - Cycle 10)
 *
 * Tests for the AddHealthVulnerabilityModal component that provides a modal dialog
 * for adding new health conditions or vulnerabilities for a person.
 *
 * The component displays different form fields based on tabType:
 * - Health form: condition dropdown, name, date_of_diagnosis, medication, status, notes
 * - Vulnerability form: description, adjustments, diagnosed checkbox, status, notes
 *
 * Following TDD RED-GREEN-BLUE methodology.
 * Expected Result: All tests FAIL (RED phase) until implementation complete.
 *
 * @module tests/components/phase2/health-vulnerabilities/AddHealthVulnerabilityModal
 */

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { axe, toHaveNoViolations } from 'jest-axe';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import type { PersonWithCounts } from '@/types/healthVulnerability';

// This import will fail in RED phase - component doesn't exist yet
import AddHealthVulnerabilityModal from '@/components/phase2/health-vulnerabilities/AddHealthVulnerabilityModal';

// Extend Jest matchers with jest-axe
expect.extend(toHaveNoViolations);

// =============================================================================
// Mock Setup
// =============================================================================

// Mock the health/vulnerability hooks
const mockCreateHealthRecord = jest.fn();
const mockCreateVulnerability = jest.fn();

jest.mock('@/hooks/useHealthVulnerabilities', () => ({
  useCreateHealthRecord: jest.fn(() => ({
    mutateAsync: mockCreateHealthRecord,
    isPending: false,
  })),
  useCreateVulnerability: jest.fn(() => ({
    mutateAsync: mockCreateVulnerability,
    isPending: false,
  })),
}));

// =============================================================================
// Mock Data
// =============================================================================

const mockPerson: PersonWithCounts = {
  id: 1,
  name: 'John Smith',
  relationship: 'Primary Owner',
  personType: 'product_owner',
  status: 'Active',
  activeCount: 0,
  inactiveCount: 0,
};

const mockSpecialRelationshipPerson: PersonWithCounts = {
  id: 10,
  name: 'Jane Doe',
  relationship: 'Spouse',
  personType: 'special_relationship',
  status: 'Active',
  activeCount: 2,
  inactiveCount: 1,
};

// =============================================================================
// Test Utilities
// =============================================================================

/**
 * Creates a wrapper with QueryClient for React Query context
 */
const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });
  return ({ children }: { children: React.ReactNode }) => (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  );
};

/**
 * Default props for health form modal
 */
const defaultHealthProps = {
  isOpen: true,
  onClose: jest.fn(),
  person: mockPerson,
  tabType: 'health' as const,
  onSuccess: jest.fn(),
};

/**
 * Default props for vulnerability form modal
 */
const defaultVulnerabilityProps = {
  isOpen: true,
  onClose: jest.fn(),
  person: mockPerson,
  tabType: 'vulnerabilities' as const,
  onSuccess: jest.fn(),
};

// =============================================================================
// Test Suite
// =============================================================================

describe('AddHealthVulnerabilityModal Component', () => {
  beforeEach(() => {
    jest.clearAllMocks();
    // Reset mock implementations to default values (isPending: false)
    const mockHooks = require('@/hooks/useHealthVulnerabilities') as any;
    mockHooks.useCreateHealthRecord.mockReturnValue({
      mutateAsync: mockCreateHealthRecord,
      isPending: false,
    });
    mockHooks.useCreateVulnerability.mockReturnValue({
      mutateAsync: mockCreateVulnerability,
      isPending: false,
    });
    mockCreateHealthRecord.mockResolvedValue({ id: 1 });
    mockCreateVulnerability.mockResolvedValue({ id: 1 });
  });

  // ===========================================================================
  // 1. Modal Rendering Tests (5 tests)
  // ===========================================================================

  describe('Modal Rendering', () => {
    it('should not render when isOpen is false', () => {
      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          isOpen={false}
        />,
        { wrapper: createWrapper() }
      );

      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });

    it('should render when isOpen is true', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByRole('dialog')).toBeInTheDocument();
    });

    it('should show person name in title', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByText(/John Smith/i)).toBeInTheDocument();
    });

    it('should show "Add Health Condition for {name}" when tabType is health', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(
        screen.getByRole('heading', { name: /add health condition for john smith/i })
      ).toBeInTheDocument();
    });

    it('should show "Add Vulnerability for {name}" when tabType is vulnerabilities', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      expect(
        screen.getByRole('heading', { name: /add vulnerability for john smith/i })
      ).toBeInTheDocument();
    });
  });

  // ===========================================================================
  // 2. Health Form Tests (8 tests)
  // ===========================================================================

  describe('Health Form', () => {
    it('should render health form fields when tabType is health', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Required field
      expect(screen.getByRole('combobox', { name: /condition/i })).toBeInTheDocument();
      // Optional fields
      expect(screen.getByLabelText(/^name$/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/diagnosed/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/medication/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/status/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/notes/i)).toBeInTheDocument();
    });

    it('should have condition dropdown with health condition options', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      expect(conditionSelect).toBeInTheDocument();

      // Should have standard health condition options
      expect(screen.getByRole('option', { name: /smoking status/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /diabetes/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /heart condition/i })).toBeInTheDocument();
    });

    it('should require condition field and show error on submit without it', async () => {
      const user = userEvent.setup();
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Submit without selecting condition
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/condition is required/i)).toBeInTheDocument();
      });
    });

    it('should have name, diagnosed date, medication, status, and notes fields', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByLabelText(/^name$/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/diagnosed/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/medication/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/status/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/notes/i)).toBeInTheDocument();
    });

    it('should default status to "Active"', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const statusSelect = screen.getByLabelText(/status/i);
      expect(statusSelect).toHaveValue('Active');
    });

    it('should have status dropdown with Active and Lapsed options', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByRole('option', { name: /^active$/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /^lapsed$/i })).toBeInTheDocument();
    });

    it('should submit health form with valid data and call onSuccess', async () => {
      const user = userEvent.setup();
      const mockOnSuccess = jest.fn();

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          onSuccess={mockOnSuccess}
        />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockCreateHealthRecord).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              condition: 'Diabetes',
              status: 'Active',
            }),
            personType: 'product_owner',
          })
        );
        expect(mockOnSuccess).toHaveBeenCalled();
      });
    });

    it('should include product_owner_id in health form submission', async () => {
      const user = userEvent.setup();

      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockCreateHealthRecord).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              product_owner_id: 1,
            }),
          })
        );
      });
    });
  });

  // ===========================================================================
  // 3. Vulnerability Form Tests (7 tests)
  // ===========================================================================

  describe('Vulnerability Form', () => {
    it('should render vulnerability form fields when tabType is vulnerabilities', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      // Required field
      expect(screen.getByLabelText(/description/i)).toBeInTheDocument();
      // Optional fields
      expect(screen.getByLabelText(/adjustments/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/professionally diagnosed/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/status/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/notes/i)).toBeInTheDocument();
    });

    it('should have description, adjustments, diagnosed checkbox, status, and notes fields', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      expect(screen.getByLabelText(/description/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/adjustments/i)).toBeInTheDocument();
      expect(screen.getByRole('checkbox', { name: /professionally diagnosed/i })).toBeInTheDocument();
      expect(screen.getByLabelText(/status/i)).toBeInTheDocument();
      expect(screen.getByLabelText(/notes/i)).toBeInTheDocument();
    });

    it('should require description field and show error on submit without it', async () => {
      const user = userEvent.setup();
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      // Submit without entering description
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/description is required/i)).toBeInTheDocument();
      });
    });

    it('should have diagnosed checkbox unchecked by default', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const diagnosedCheckbox = screen.getByRole('checkbox', { name: /professionally diagnosed/i });
      expect(diagnosedCheckbox).not.toBeChecked();
    });

    it('should default status to "Active" for vulnerability form', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const statusSelect = screen.getByLabelText(/status/i);
      expect(statusSelect).toHaveValue('Active');
    });

    it('should submit vulnerability form with valid data and call onSuccess', async () => {
      const user = userEvent.setup();
      const mockOnSuccess = jest.fn();

      render(
        <AddHealthVulnerabilityModal
          {...defaultVulnerabilityProps}
          onSuccess={mockOnSuccess}
        />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const descriptionInput = screen.getByLabelText(/description/i);
      await user.type(descriptionInput, 'Cognitive decline affecting financial decisions');

      // Check the diagnosed checkbox
      const diagnosedCheckbox = screen.getByRole('checkbox', { name: /professionally diagnosed/i });
      await user.click(diagnosedCheckbox);

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockCreateVulnerability).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              description: 'Cognitive decline affecting financial decisions',
              diagnosed: true,
              status: 'Active',
            }),
            personType: 'product_owner',
          })
        );
        expect(mockOnSuccess).toHaveBeenCalled();
      });
    });

    it('should include product_owner_id in vulnerability form submission', async () => {
      const user = userEvent.setup();

      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const descriptionInput = screen.getByLabelText(/description/i);
      await user.type(descriptionInput, 'Test vulnerability');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockCreateVulnerability).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              product_owner_id: 1,
            }),
          })
        );
      });
    });
  });

  // ===========================================================================
  // 4. Modal Actions Tests (4 tests)
  // ===========================================================================

  describe('Modal Actions', () => {
    it('should call onClose when Cancel button is clicked', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      const cancelButton = screen.getByRole('button', { name: /cancel/i });
      await user.click(cancelButton);

      expect(mockOnClose).toHaveBeenCalledTimes(1);
    });

    it('should call onClose when X button is clicked', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      const closeButton = screen.getByRole('button', { name: /close modal/i });
      await user.click(closeButton);

      expect(mockOnClose).toHaveBeenCalledTimes(1);
    });

    it('should close modal on Escape key press', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      await user.keyboard('{Escape}');

      expect(mockOnClose).toHaveBeenCalledTimes(1);
    });

    it('should close modal on backdrop click', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      const backdrop = screen.getByTestId('modal-backdrop');
      await user.click(backdrop);

      expect(mockOnClose).toHaveBeenCalledTimes(1);
    });
  });

  // ===========================================================================
  // 5. Accessibility Tests (10 tests)
  // ===========================================================================

  describe('Accessibility', () => {
    it('should have no accessibility violations for health form (jest-axe)', async () => {
      const { container } = render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });

    it('should have no accessibility violations for vulnerability form (jest-axe)', async () => {
      const { container } = render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });

    it('should trap focus within modal', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Verify modal has focusable elements for focus trap
      const modal = screen.getByRole('dialog');
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      // Modal should have focusable elements for focus trap to work
      expect(focusableElements.length).toBeGreaterThan(0);
      // Modal should be in the DOM (focus trap is handled by FocusTrap component)
      expect(modal).toBeInTheDocument();
    });

    it('should have aria-labelledby pointing to dialog title', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const dialog = screen.getByRole('dialog');
      const labelledBy = dialog.getAttribute('aria-labelledby');
      expect(labelledBy).toBeTruthy();

      // The element referenced by aria-labelledby should exist
      const titleElement = document.getElementById(labelledBy!);
      expect(titleElement).toBeInTheDocument();
      expect(titleElement).toHaveTextContent(/add health condition/i);
    });

    it('should have proper form labels for all fields (health form)', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // All form fields should have associated labels
      const conditionField = screen.getByRole('combobox', { name: /condition/i });
      expect(conditionField).toHaveAttribute('id');

      const nameField = screen.getByLabelText(/^name$/i);
      expect(nameField).toHaveAttribute('id');

      const statusField = screen.getByLabelText(/status/i);
      expect(statusField).toHaveAttribute('id');

      const notesField = screen.getByLabelText(/notes/i);
      expect(notesField).toHaveAttribute('id');
    });

    it('should show aria-live region when there is an announcement', () => {
      // The aria-live region only appears when there's an announcement (success/error)
      // Initially there is no live region, but one will appear on success or error
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Initially no status region (empty div was removed for accessibility best practices)
      const liveRegion = screen.queryByRole('status');
      // Status region only appears when there's a message to announce
      // This is tested via the success and error submission tests
      expect(liveRegion).not.toBeInTheDocument();
    });

    it('should return focus to trigger element after close', async () => {
      const user = userEvent.setup();
      const triggerRef = React.createRef<HTMLButtonElement>();

      const TestComponent = () => {
        const [isOpen, setIsOpen] = React.useState(false);
        return (
          <>
            <button ref={triggerRef} onClick={() => setIsOpen(true)}>
              Open Modal
            </button>
            <AddHealthVulnerabilityModal
              {...defaultHealthProps}
              isOpen={isOpen}
              onClose={() => setIsOpen(false)}
              triggerRef={triggerRef}
            />
          </>
        );
      };

      render(<TestComponent />, { wrapper: createWrapper() });

      // Open modal
      const openButton = screen.getByRole('button', { name: /open modal/i });
      await user.click(openButton);

      // Verify modal is open
      await waitFor(() => {
        expect(screen.getByRole('dialog')).toBeInTheDocument();
      });

      // Close modal with Escape
      await user.keyboard('{Escape}');

      // Focus should return to trigger
      await waitFor(() => {
        expect(document.activeElement).toBe(openButton);
      });
    });

    it('should announce success via aria-live polite', async () => {
      const user = userEvent.setup();

      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        const statusRegion = screen.getByRole('status');
        expect(statusRegion).toHaveAttribute('aria-live', 'polite');
        expect(statusRegion).toHaveTextContent(/success|saved|added/i);
      });
    });

    it('should announce error via aria-live assertive', async () => {
      const user = userEvent.setup();
      mockCreateHealthRecord.mockRejectedValue(new Error('Server error'));

      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        const alertRegion = screen.getByRole('alert');
        expect(alertRegion).toHaveAttribute('aria-live', 'assertive');
        expect(alertRegion).toHaveTextContent(/error|failed/i);
      });
    });

    it('should have aria-modal="true" on dialog', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const dialog = screen.getByRole('dialog');
      expect(dialog).toHaveAttribute('aria-modal', 'true');
    });
  });

  // ===========================================================================
  // 6. Inline Validation Tests (5 tests)
  // ===========================================================================

  describe('Inline Validation', () => {
    it('should show error on blur for empty required field', async () => {
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const descriptionInput = screen.getByLabelText(/description/i);

      // Focus and blur without entering value
      fireEvent.focus(descriptionInput);
      fireEvent.blur(descriptionInput);

      await waitFor(() => {
        expect(screen.getByText(/description is required/i)).toBeInTheDocument();
      });
    });

    it('should clear error when valid value entered', async () => {
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const descriptionInput = screen.getByLabelText(/description/i);

      // Trigger validation error
      fireEvent.focus(descriptionInput);
      fireEvent.blur(descriptionInput);

      await waitFor(() => {
        expect(screen.getByText(/description is required/i)).toBeInTheDocument();
      });

      // Enter valid value
      fireEvent.change(descriptionInput, { target: { value: 'Valid description' } });

      await waitFor(() => {
        expect(screen.queryByText(/description is required/i)).not.toBeInTheDocument();
      });
    });

    it('should show visual error styling (border-red) on invalid field', async () => {
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const descriptionInput = screen.getByLabelText(/description/i);

      // Trigger validation error
      fireEvent.focus(descriptionInput);
      fireEvent.blur(descriptionInput);

      await waitFor(() => {
        expect(descriptionInput).toHaveClass('border-red-300');
      });
    });

    it('should show all validation errors on submit', async () => {
      const user = userEvent.setup();
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      // Submit without filling required fields
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/description is required/i)).toBeInTheDocument();
      });
    });

    it('should clear all errors when form resets', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();

      const TestComponent = () => {
        const [isOpen, setIsOpen] = React.useState(true);
        return (
          <AddHealthVulnerabilityModal
            {...defaultVulnerabilityProps}
            isOpen={isOpen}
            onClose={() => {
              mockOnClose();
              setIsOpen(false);
            }}
          />
        );
      };

      const { rerender } = render(<TestComponent />, { wrapper: createWrapper() });

      // Trigger validation error
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/description is required/i)).toBeInTheDocument();
      });

      // Close and reopen modal
      const cancelButton = screen.getByRole('button', { name: /cancel/i });
      await user.click(cancelButton);

      // Reopen the modal
      const ReopenComponent = () => (
        <AddHealthVulnerabilityModal
          {...defaultVulnerabilityProps}
          isOpen={true}
          onClose={mockOnClose}
        />
      );

      rerender(
        <QueryClientProvider client={new QueryClient({ defaultOptions: { queries: { retry: false } } })}>
          <ReopenComponent />
        </QueryClientProvider>
      );

      // Error should be cleared
      await waitFor(() => {
        expect(screen.queryByText(/description is required/i)).not.toBeInTheDocument();
      });
    });
  });

  // ===========================================================================
  // 7. Edge Cases Tests (6 tests)
  // ===========================================================================

  describe('Edge Cases', () => {
    it('should reset form when modal closes and reopens', async () => {
      const user = userEvent.setup();

      const TestComponent = () => {
        const [isOpen, setIsOpen] = React.useState(true);
        return (
          <>
            <button onClick={() => setIsOpen(true)}>Reopen</button>
            <AddHealthVulnerabilityModal
              {...defaultVulnerabilityProps}
              isOpen={isOpen}
              onClose={() => setIsOpen(false)}
            />
          </>
        );
      };

      render(<TestComponent />, { wrapper: createWrapper() });

      // Enter some data
      const descriptionInput = screen.getByLabelText(/description/i);
      await user.type(descriptionInput, 'Test description');

      expect(descriptionInput).toHaveValue('Test description');

      // Close modal
      const cancelButton = screen.getByRole('button', { name: /cancel/i });
      await user.click(cancelButton);

      // Reopen modal
      const reopenButton = screen.getByRole('button', { name: /reopen/i });
      await user.click(reopenButton);

      // Form should be reset
      await waitFor(() => {
        const newDescriptionInput = screen.getByLabelText(/description/i);
        expect(newDescriptionInput).toHaveValue('');
      });
    });

    it('should handle special characters in input', async () => {
      const user = userEvent.setup();

      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const descriptionInput = screen.getByLabelText(/description/i);
      await user.type(descriptionInput, "O'Brien's condition - <test> & \"special\" chars");

      expect(descriptionInput).toHaveValue("O'Brien's condition - <test> & \"special\" chars");
    });

    it('should handle unicode characters', async () => {
      const user = userEvent.setup();

      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const descriptionInput = screen.getByLabelText(/description/i);
      await user.type(descriptionInput, '\u8A8D\u77E5\u969C\u5BB3 - \u8A8D\u77E5\u75C7');

      expect(descriptionInput).toHaveValue('\u8A8D\u77E5\u969C\u5BB3 - \u8A8D\u77E5\u75C7');
    });

    it('should prevent double submission by disabling button during submit', async () => {
      const user = userEvent.setup();

      // Make the mutation hang to simulate in-progress state
      mockCreateVulnerability.mockImplementation(
        () => new Promise(resolve => setTimeout(() => resolve({ id: 1 }), 1000))
      );

      // Re-mock the hook to return isPending: true
      const { useCreateVulnerability } = jest.requireMock('@/hooks/useHealthVulnerabilities');
      useCreateVulnerability.mockReturnValue({
        mutateAsync: mockCreateVulnerability,
        isPending: true,
      });

      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const descriptionInput = screen.getByLabelText(/description/i);
      await user.type(descriptionInput, 'Test description');

      // Submit button should be disabled when isPending is true
      const submitButton = screen.getByRole('button', { name: /save|add|submit|saving/i });
      expect(submitButton).toBeDisabled();
    });

    it('should handle long text in notes field', () => {
      const longText = 'A'.repeat(2000);

      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const notesField = screen.getByLabelText(/notes/i);
      // Use fireEvent.change for performance with long text
      fireEvent.change(notesField, { target: { value: longText } });

      expect(notesField).toHaveValue(longText);
    });

    it('should handle special_relationship personType correctly', async () => {
      const user = userEvent.setup();

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          person={mockSpecialRelationshipPerson}
        />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockCreateHealthRecord).toHaveBeenCalledWith(
          expect.objectContaining({
            data: expect.objectContaining({
              special_relationship_id: 10,
            }),
            personType: 'special_relationship',
          })
        );
      });
    });
  });

  // ===========================================================================
  // 8. Keyboard Navigation Tests (3 tests)
  // ===========================================================================

  describe('Keyboard Navigation', () => {
    it('should allow Tab navigation through form fields', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const modal = screen.getByRole('dialog');

      // Verify modal contains focusable form elements for tab navigation
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      // Should have multiple focusable elements (form fields + buttons)
      expect(focusableElements.length).toBeGreaterThan(3);

      // Verify key form elements are focusable
      expect(screen.getByRole('combobox', { name: /condition/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /save/i })).toBeInTheDocument();
      expect(screen.getByRole('button', { name: /cancel/i })).toBeInTheDocument();
    });

    it('should allow Enter key to submit form when focus is on submit button', async () => {
      const user = userEvent.setup();
      const mockOnSuccess = jest.fn();

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          onSuccess={mockOnSuccess}
        />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Focus submit button and press Enter
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      submitButton.focus();
      await user.keyboard('{Enter}');

      await waitFor(() => {
        expect(mockCreateHealthRecord).toHaveBeenCalled();
      });
    });

    it('should allow Shift+Tab for reverse navigation', () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const modal = screen.getByRole('dialog');

      // Verify modal has FocusTrap set up with proper focusable elements
      // In a real browser, FocusTrap handles Tab/Shift+Tab cycling
      const focusableElements = modal.querySelectorAll(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );

      // Should have enough focusable elements for navigation
      expect(focusableElements.length).toBeGreaterThan(2);

      // Verify first and last focusable elements exist (needed for Shift+Tab cycling)
      expect(focusableElements[0]).toBeInTheDocument();
      expect(focusableElements[focusableElements.length - 1]).toBeInTheDocument();
    });
  });

  // ===========================================================================
  // 9. Form Field Interactions Tests (5 tests)
  // ===========================================================================

  describe('Form Field Interactions', () => {
    it('should allow changing condition selection in health form', async () => {
      const user = userEvent.setup();
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });

      // Select first option
      await user.selectOptions(conditionSelect, 'Diabetes');
      expect(conditionSelect).toHaveValue('Diabetes');

      // Change selection
      await user.selectOptions(conditionSelect, 'Heart Condition');
      expect(conditionSelect).toHaveValue('Heart Condition');
    });

    it('should allow toggling diagnosed checkbox in vulnerability form', async () => {
      const user = userEvent.setup();
      render(
        <AddHealthVulnerabilityModal {...defaultVulnerabilityProps} />,
        { wrapper: createWrapper() }
      );

      const diagnosedCheckbox = screen.getByRole('checkbox', { name: /professionally diagnosed/i });

      expect(diagnosedCheckbox).not.toBeChecked();

      await user.click(diagnosedCheckbox);
      expect(diagnosedCheckbox).toBeChecked();

      await user.click(diagnosedCheckbox);
      expect(diagnosedCheckbox).not.toBeChecked();
    });

    it('should allow changing status in health form', async () => {
      const user = userEvent.setup();
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const statusSelect = screen.getByLabelText(/status/i);

      // Default should be Active
      expect(statusSelect).toHaveValue('Active');

      // Change to Lapsed
      await user.selectOptions(statusSelect, 'Lapsed');
      expect(statusSelect).toHaveValue('Lapsed');
    });

    it('should allow entering optional medication field in health form', async () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const medicationInput = screen.getByLabelText(/medication/i);
      fireEvent.change(medicationInput, { target: { value: 'Metformin 500mg twice daily' } });

      expect(medicationInput).toHaveValue('Metformin 500mg twice daily');
    });

    it('should allow entering date of diagnosis in health form', async () => {
      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const dateInput = screen.getByLabelText(/date diagnosed/i);
      fireEvent.change(dateInput, { target: { value: '2024-01-15' } });

      expect(dateInput).toHaveValue('2024-01-15');
    });
  });

  // ===========================================================================
  // 10. Error Handling Tests (3 tests)
  // ===========================================================================

  describe('Error Handling', () => {
    it('should display error message when API call fails', async () => {
      const user = userEvent.setup();
      mockCreateHealthRecord.mockRejectedValue(new Error('Network error'));

      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(screen.getByText(/error|failed/i)).toBeInTheDocument();
      });
    });

    it('should not call onSuccess when API call fails', async () => {
      const user = userEvent.setup();
      const mockOnSuccess = jest.fn();
      mockCreateHealthRecord.mockRejectedValue(new Error('Server error'));

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          onSuccess={mockOnSuccess}
        />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockCreateHealthRecord).toHaveBeenCalled();
      });

      // onSuccess should not be called on error
      expect(mockOnSuccess).not.toHaveBeenCalled();
    });

    it('should not close modal when API call fails', async () => {
      const user = userEvent.setup();
      const mockOnClose = jest.fn();
      mockCreateHealthRecord.mockRejectedValue(new Error('Server error'));

      render(
        <AddHealthVulnerabilityModal
          {...defaultHealthProps}
          onClose={mockOnClose}
        />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      // Submit form
      const submitButton = screen.getByRole('button', { name: /save|add|submit/i });
      await user.click(submitButton);

      await waitFor(() => {
        expect(mockCreateHealthRecord).toHaveBeenCalled();
      });

      // Modal should remain open
      expect(mockOnClose).not.toHaveBeenCalled();
      expect(screen.getByRole('dialog')).toBeInTheDocument();
    });
  });

  // ===========================================================================
  // 11. Loading State Tests (2 tests)
  // ===========================================================================

  describe('Loading State', () => {
    it('should show loading indicator on submit button when submitting', async () => {
      const user = userEvent.setup();

      // Mock the hook to return isPending: true
      const { useCreateHealthRecord } = jest.requireMock('@/hooks/useHealthVulnerabilities');
      useCreateHealthRecord.mockReturnValue({
        mutateAsync: mockCreateHealthRecord,
        isPending: true,
      });

      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      // Fill required field
      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      await user.selectOptions(conditionSelect, 'Diabetes');

      const submitButton = screen.getByRole('button', { name: /saving|loading/i });
      expect(submitButton).toBeDisabled();
    });

    it('should disable form inputs while submitting', async () => {
      const user = userEvent.setup();

      // Mock the hook to return isPending: true
      const { useCreateHealthRecord } = jest.requireMock('@/hooks/useHealthVulnerabilities');
      useCreateHealthRecord.mockReturnValue({
        mutateAsync: mockCreateHealthRecord,
        isPending: true,
      });

      render(
        <AddHealthVulnerabilityModal {...defaultHealthProps} />,
        { wrapper: createWrapper() }
      );

      const conditionSelect = screen.getByRole('combobox', { name: /condition/i });
      const statusSelect = screen.getByLabelText(/status/i);

      expect(conditionSelect).toBeDisabled();
      expect(statusSelect).toBeDisabled();
    });
  });
});
