/**
 * Type Definition Tests for Health and Vulnerability Types
 * Cycle 5: Red Phase - Tests should FAIL if types are missing or incorrectly defined
 *
 * Tests type definitions and interfaces for the Health & Vulnerabilities Tab feature.
 * These types support the FCA's vulnerability guidance for treating customers fairly.
 */

// This import will fail if types don't exist - forcing test failure
import * as HealthVulnerabilityTypes from '@/types/healthVulnerability';

import type {
  // Shared types
  HealthVulnerabilityStatus,
  PersonType,
  PersonReference,
  // Health types
  HealthProductOwner,
  HealthSpecialRelationship,
  HealthProductOwnerCreate,
  HealthSpecialRelationshipCreate,
  HealthConditionUpdate,
  HealthCondition,
  HealthConditionWithPerson,
  // Vulnerability types
  VulnerabilityProductOwner,
  VulnerabilitySpecialRelationship,
  VulnerabilityProductOwnerCreate,
  VulnerabilitySpecialRelationshipCreate,
  VulnerabilityUpdate,
  Vulnerability,
  VulnerabilityWithPerson,
  // Query/Response types
  HealthQueryParams,
  VulnerabilityQueryParams,
  PaginationMeta,
  // Modal/Form types
  ModalMode,
  RecordType,
  HealthVulnerabilityModalProps,
} from '@/types/healthVulnerability';

import {
  HEALTH_FIELD_LIMITS,
  VULNERABILITY_FIELD_LIMITS,
  STATUS_OPTIONS,
  // Type guards
  isHealthProductOwner,
  isHealthSpecialRelationship,
  isVulnerabilityProductOwner,
  isVulnerabilitySpecialRelationship,
  // Date utilities
  parseHealthDate,
  formatHealthDate,
} from '@/types/healthVulnerability';

describe('Health and Vulnerability Type Definitions', () => {
  describe('Module Exports', () => {
    it('should export all required types from module', () => {
      // This test verifies the module exists and exports the right types
      expect(HealthVulnerabilityTypes).toBeDefined();
    });

    it('should export HEALTH_FIELD_LIMITS constant', () => {
      expect(HEALTH_FIELD_LIMITS).toBeDefined();
      expect(typeof HEALTH_FIELD_LIMITS).toBe('object');
    });

    it('should export VULNERABILITY_FIELD_LIMITS constant', () => {
      expect(VULNERABILITY_FIELD_LIMITS).toBeDefined();
      expect(typeof VULNERABILITY_FIELD_LIMITS).toBe('object');
    });

    it('should export STATUS_OPTIONS constant', () => {
      expect(STATUS_OPTIONS).toBeDefined();
      expect(Array.isArray(STATUS_OPTIONS)).toBe(true);
    });
  });

  describe('Shared Types', () => {
    describe('HealthVulnerabilityStatus', () => {
      it('should accept all valid status values', () => {
        const validStatuses: HealthVulnerabilityStatus[] = [
          'Active',
          'Resolved',
          'Monitoring',
          'Inactive',
        ];

        validStatuses.forEach(status => {
          const testStatus: HealthVulnerabilityStatus = status;
          expect(testStatus).toBe(status);
        });
      });

      it('should match STATUS_OPTIONS constant', () => {
        const expectedStatuses: HealthVulnerabilityStatus[] = [
          'Active',
          'Resolved',
          'Monitoring',
          'Inactive',
        ];

        expectedStatuses.forEach(status => {
          expect(STATUS_OPTIONS).toContain(status);
        });
        expect(STATUS_OPTIONS.length).toBe(4);
      });
    });

    describe('PersonType', () => {
      it('should accept product_owner and special_relationship values', () => {
        const validTypes: PersonType[] = ['product_owner', 'special_relationship'];

        validTypes.forEach(type => {
          const testType: PersonType = type;
          expect(testType).toBe(type);
        });
      });
    });

    describe('PersonReference', () => {
      it('should define person reference structure with all required fields', () => {
        const personRef: PersonReference = {
          type: 'product_owner',
          id: 123,
          name: 'John Doe',
        };

        expect(personRef.type).toBe('product_owner');
        expect(personRef.id).toBe(123);
        expect(personRef.name).toBe('John Doe');
      });

      it('should work with special_relationship type', () => {
        const personRef: PersonReference = {
          type: 'special_relationship',
          id: 456,
          name: 'Jane Smith',
        };

        expect(personRef.type).toBe('special_relationship');
        expect(personRef.id).toBe(456);
        expect(personRef.name).toBe('Jane Smith');
      });
    });
  });

  describe('Health Types', () => {
    describe('HealthProductOwner Interface', () => {
      it('should define complete health condition structure with all required fields', () => {
        const healthRecord: HealthProductOwner = {
          id: 1,
          product_owner_id: 100,
          condition: 'Diabetes',
          name: 'Type 2 Diabetes',
          date_of_diagnosis: '2020-05-15',
          status: 'Active',
          medication: 'Metformin 500mg',
          notes: 'Monitor blood sugar levels regularly',
          created_at: '2025-01-01T10:00:00Z',
          date_recorded: '2025-01-01T10:00:00Z',
        };

        expect(healthRecord.id).toBe(1);
        expect(healthRecord.product_owner_id).toBe(100);
        expect(healthRecord.condition).toBe('Diabetes');
        expect(healthRecord.status).toBe('Active');
        expect(healthRecord.created_at).toBeDefined();
      });

      it('should allow null values for optional fields', () => {
        const healthRecord: HealthProductOwner = {
          id: 2,
          product_owner_id: 101,
          condition: 'Heart Disease',
          status: 'Monitoring',
          created_at: '2025-01-01T11:00:00Z',
          name: null,
          date_of_diagnosis: null,
          medication: null,
          notes: null,
          date_recorded: null,
        };

        expect(healthRecord.name).toBeNull();
        expect(healthRecord.date_of_diagnosis).toBeNull();
        expect(healthRecord.medication).toBeNull();
        expect(healthRecord.notes).toBeNull();
        expect(healthRecord.date_recorded).toBeNull();
      });
    });

    describe('HealthSpecialRelationship Interface', () => {
      it('should define health condition for special relationships', () => {
        const healthRecord: HealthSpecialRelationship = {
          id: 10,
          special_relationship_id: 200,
          condition: 'Dementia',
          name: 'Early-stage Alzheimer\'s',
          date_of_diagnosis: '2023-03-20',
          status: 'Active',
          medication: 'Donepezil',
          notes: 'Requires supervision for financial decisions',
          created_at: '2025-01-01T12:00:00Z',
          date_recorded: null,
        };

        expect(healthRecord.special_relationship_id).toBe(200);
        expect(healthRecord.condition).toBe('Dementia');
        expect(healthRecord.status).toBe('Active');
      });
    });

    describe('HealthProductOwnerCreate Interface', () => {
      it('should define create payload structure', () => {
        const createPayload: HealthProductOwnerCreate = {
          product_owner_id: 100,
          condition: 'Arthritis',
          name: 'Rheumatoid Arthritis',
          date_of_diagnosis: '2022-06-10',
          status: 'Active',
          medication: 'Methotrexate',
          notes: 'Affects fine motor control',
        };

        expect(createPayload.product_owner_id).toBe(100);
        expect(createPayload.condition).toBe('Arthritis');
        expect('id' in createPayload).toBe(false);
        expect('created_at' in createPayload).toBe(false);
      });

      it('should allow optional fields to be omitted', () => {
        const minimalPayload: HealthProductOwnerCreate = {
          product_owner_id: 101,
          condition: 'Asthma',
        };

        expect(minimalPayload.product_owner_id).toBe(101);
        expect(minimalPayload.condition).toBe('Asthma');
        expect(minimalPayload.name).toBeUndefined();
        expect(minimalPayload.status).toBeUndefined();
      });
    });

    describe('HealthSpecialRelationshipCreate Interface', () => {
      it('should define create payload for special relationships', () => {
        const createPayload: HealthSpecialRelationshipCreate = {
          special_relationship_id: 200,
          condition: 'Vision Impairment',
          status: 'Active',
        };

        expect(createPayload.special_relationship_id).toBe(200);
        expect(createPayload.condition).toBe('Vision Impairment');
        expect('id' in createPayload).toBe(false);
      });
    });

    describe('HealthConditionUpdate Interface', () => {
      it('should allow all fields to be optional for partial updates', () => {
        const updatePayload: HealthConditionUpdate = {
          status: 'Resolved',
        };

        expect(updatePayload.status).toBe('Resolved');
        expect(updatePayload.condition).toBeUndefined();
        expect(updatePayload.medication).toBeUndefined();
      });

      it('should allow updating multiple fields', () => {
        const updatePayload: HealthConditionUpdate = {
          condition: 'Updated Condition',
          status: 'Monitoring',
          notes: 'Updated notes',
          medication: 'New medication',
        };

        expect(updatePayload.condition).toBe('Updated Condition');
        expect(updatePayload.status).toBe('Monitoring');
        expect(updatePayload.notes).toBe('Updated notes');
      });
    });

    describe('HealthCondition Union Type', () => {
      it('should accept HealthProductOwner', () => {
        const record: HealthCondition = {
          id: 1,
          product_owner_id: 100,
          condition: 'Test',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        } as HealthProductOwner;

        expect(record.id).toBe(1);
      });

      it('should accept HealthSpecialRelationship', () => {
        const record: HealthCondition = {
          id: 2,
          special_relationship_id: 200,
          condition: 'Test',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        } as HealthSpecialRelationship;

        expect(record.id).toBe(2);
      });
    });

    describe('HealthConditionWithPerson Interface', () => {
      it('should include person reference in health condition', () => {
        const recordWithPerson: HealthConditionWithPerson = {
          id: 1,
          condition: 'Diabetes',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
          date_recorded: null,
          person: {
            type: 'product_owner',
            id: 100,
            name: 'John Doe',
          },
        };

        expect(recordWithPerson.person.type).toBe('product_owner');
        expect(recordWithPerson.person.name).toBe('John Doe');
        expect(recordWithPerson.condition).toBe('Diabetes');
      });
    });
  });

  describe('Vulnerability Types', () => {
    describe('VulnerabilityProductOwner Interface', () => {
      it('should define complete vulnerability structure with all required fields', () => {
        const vulnRecord: VulnerabilityProductOwner = {
          id: 1,
          product_owner_id: 100,
          description: 'Cognitive decline affecting financial decisions',
          adjustments: 'Speak slowly, provide written summaries',
          diagnosed: true,
          status: 'Active',
          notes: 'Family member should be present at meetings',
          created_at: '2025-01-01T10:00:00Z',
          date_recorded: '2025-01-01T10:00:00Z',
        };

        expect(vulnRecord.id).toBe(1);
        expect(vulnRecord.product_owner_id).toBe(100);
        expect(vulnRecord.description).toContain('Cognitive decline');
        expect(vulnRecord.diagnosed).toBe(true);
        expect(vulnRecord.status).toBe('Active');
      });

      it('should allow null values for optional fields', () => {
        const vulnRecord: VulnerabilityProductOwner = {
          id: 2,
          product_owner_id: 101,
          description: 'Hearing impairment',
          diagnosed: false,
          status: 'Active',
          created_at: '2025-01-01T11:00:00Z',
          adjustments: null,
          notes: null,
          date_recorded: null,
        };

        expect(vulnRecord.adjustments).toBeNull();
        expect(vulnRecord.notes).toBeNull();
        expect(vulnRecord.diagnosed).toBe(false);
      });
    });

    describe('VulnerabilitySpecialRelationship Interface', () => {
      it('should define vulnerability for special relationships', () => {
        const vulnRecord: VulnerabilitySpecialRelationship = {
          id: 10,
          special_relationship_id: 200,
          description: 'Recent bereavement affecting judgment',
          adjustments: 'Delay major financial decisions if possible',
          diagnosed: false,
          status: 'Monitoring',
          notes: 'Review in 6 months',
          created_at: '2025-01-01T12:00:00Z',
          date_recorded: null,
        };

        expect(vulnRecord.special_relationship_id).toBe(200);
        expect(vulnRecord.description).toContain('bereavement');
        expect(vulnRecord.status).toBe('Monitoring');
      });
    });

    describe('VulnerabilityProductOwnerCreate Interface', () => {
      it('should define create payload structure', () => {
        const createPayload: VulnerabilityProductOwnerCreate = {
          product_owner_id: 100,
          description: 'Memory issues',
          adjustments: 'Provide written confirmation of all discussions',
          diagnosed: true,
          status: 'Active',
          notes: 'Medical documentation available',
        };

        expect(createPayload.product_owner_id).toBe(100);
        expect(createPayload.description).toBe('Memory issues');
        expect(createPayload.diagnosed).toBe(true);
        expect('id' in createPayload).toBe(false);
        expect('created_at' in createPayload).toBe(false);
      });

      it('should allow optional fields to be omitted', () => {
        const minimalPayload: VulnerabilityProductOwnerCreate = {
          product_owner_id: 101,
          description: 'Visual impairment',
        };

        expect(minimalPayload.product_owner_id).toBe(101);
        expect(minimalPayload.description).toBe('Visual impairment');
        expect(minimalPayload.diagnosed).toBeUndefined();
        expect(minimalPayload.status).toBeUndefined();
      });
    });

    describe('VulnerabilitySpecialRelationshipCreate Interface', () => {
      it('should define create payload for special relationships', () => {
        const createPayload: VulnerabilitySpecialRelationshipCreate = {
          special_relationship_id: 200,
          description: 'Language barrier',
          diagnosed: false,
          status: 'Active',
        };

        expect(createPayload.special_relationship_id).toBe(200);
        expect(createPayload.description).toBe('Language barrier');
        expect('id' in createPayload).toBe(false);
      });
    });

    describe('VulnerabilityUpdate Interface', () => {
      it('should allow all fields to be optional for partial updates', () => {
        const updatePayload: VulnerabilityUpdate = {
          status: 'Resolved',
        };

        expect(updatePayload.status).toBe('Resolved');
        expect(updatePayload.description).toBeUndefined();
        expect(updatePayload.diagnosed).toBeUndefined();
      });

      it('should allow updating multiple fields', () => {
        const updatePayload: VulnerabilityUpdate = {
          description: 'Updated description',
          status: 'Inactive',
          diagnosed: true,
          adjustments: 'New adjustments',
          notes: 'Updated notes',
        };

        expect(updatePayload.description).toBe('Updated description');
        expect(updatePayload.status).toBe('Inactive');
        expect(updatePayload.diagnosed).toBe(true);
      });
    });

    describe('Vulnerability Union Type', () => {
      it('should accept VulnerabilityProductOwner', () => {
        const record: Vulnerability = {
          id: 1,
          product_owner_id: 100,
          description: 'Test',
          diagnosed: false,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        } as VulnerabilityProductOwner;

        expect(record.id).toBe(1);
      });

      it('should accept VulnerabilitySpecialRelationship', () => {
        const record: Vulnerability = {
          id: 2,
          special_relationship_id: 200,
          description: 'Test',
          diagnosed: false,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        } as VulnerabilitySpecialRelationship;

        expect(record.id).toBe(2);
      });
    });

    describe('VulnerabilityWithPerson Interface', () => {
      it('should include person reference in vulnerability', () => {
        const recordWithPerson: VulnerabilityWithPerson = {
          id: 1,
          description: 'Memory issues',
          diagnosed: true,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
          date_recorded: null,
          person: {
            type: 'special_relationship',
            id: 200,
            name: 'Jane Smith',
          },
        };

        expect(recordWithPerson.person.type).toBe('special_relationship');
        expect(recordWithPerson.person.name).toBe('Jane Smith');
        expect(recordWithPerson.description).toBe('Memory issues');
      });
    });
  });

  describe('Query and Response Types', () => {
    describe('HealthQueryParams Interface', () => {
      it('should define query parameters for health conditions', () => {
        const params: HealthQueryParams = {
          product_owner_id: 100,
          client_group_id: 50,
          skip: 0,
          limit: 25,
        };

        expect(params.product_owner_id).toBe(100);
        expect(params.client_group_id).toBe(50);
        expect(params.skip).toBe(0);
        expect(params.limit).toBe(25);
      });

      it('should allow all params to be optional', () => {
        const params: HealthQueryParams = {};

        expect(params.product_owner_id).toBeUndefined();
        expect(params.special_relationship_id).toBeUndefined();
      });
    });

    describe('VulnerabilityQueryParams Interface', () => {
      it('should define query parameters for vulnerabilities', () => {
        const params: VulnerabilityQueryParams = {
          special_relationship_id: 200,
          skip: 10,
          limit: 50,
        };

        expect(params.special_relationship_id).toBe(200);
        expect(params.skip).toBe(10);
        expect(params.limit).toBe(50);
      });
    });

    describe('PaginationMeta Interface', () => {
      it('should define pagination metadata structure', () => {
        const meta: PaginationMeta = {
          total: 100,
          skip: 0,
          limit: 25,
          hasMore: true,
        };

        expect(meta.total).toBe(100);
        expect(meta.skip).toBe(0);
        expect(meta.limit).toBe(25);
        expect(meta.hasMore).toBe(true);
      });

      it('should indicate when no more records available', () => {
        const meta: PaginationMeta = {
          total: 10,
          skip: 0,
          limit: 25,
          hasMore: false,
        };

        expect(meta.hasMore).toBe(false);
      });
    });
  });

  describe('Modal and Form Types', () => {
    describe('ModalMode Type', () => {
      it('should accept all valid modal modes', () => {
        const modes: ModalMode[] = ['add', 'edit', 'view'];

        modes.forEach(mode => {
          const testMode: ModalMode = mode;
          expect(testMode).toBe(mode);
        });
      });
    });

    describe('RecordType Type', () => {
      it('should accept health and vulnerability values', () => {
        const types: RecordType[] = ['health', 'vulnerability'];

        types.forEach(type => {
          const testType: RecordType = type;
          expect(testType).toBe(type);
        });
      });
    });

    describe('HealthVulnerabilityModalProps Interface', () => {
      it('should define modal props structure', () => {
        const mockOnClose = jest.fn();
        const mockOnSave = jest.fn();

        const props: HealthVulnerabilityModalProps = {
          isOpen: true,
          onClose: mockOnClose,
          onSave: mockOnSave,
          recordType: 'health',
          mode: 'add',
          person: {
            type: 'product_owner',
            id: 100,
            name: 'John Doe',
          },
        };

        expect(props.isOpen).toBe(true);
        expect(props.recordType).toBe('health');
        expect(props.mode).toBe('add');
        expect(props.person.name).toBe('John Doe');
        expect(props.existingRecord).toBeUndefined();
      });

      it('should allow existingRecord for edit mode', () => {
        const mockOnClose = jest.fn();
        const mockOnSave = jest.fn();
        const existingHealth: HealthProductOwner = {
          id: 1,
          product_owner_id: 100,
          condition: 'Diabetes',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        const props: HealthVulnerabilityModalProps = {
          isOpen: true,
          onClose: mockOnClose,
          onSave: mockOnSave,
          recordType: 'health',
          mode: 'edit',
          person: {
            type: 'product_owner',
            id: 100,
            name: 'John Doe',
          },
          existingRecord: existingHealth,
        };

        expect(props.mode).toBe('edit');
        expect(props.existingRecord).toBeDefined();
        expect((props.existingRecord as HealthProductOwner).condition).toBe('Diabetes');
      });
    });
  });

  describe('Constants', () => {
    describe('HEALTH_FIELD_LIMITS', () => {
      it('should have correct field limit values', () => {
        expect(HEALTH_FIELD_LIMITS.condition).toBe(255);
        expect(HEALTH_FIELD_LIMITS.name).toBe(255);
        expect(HEALTH_FIELD_LIMITS.medication).toBe(500);
        expect(HEALTH_FIELD_LIMITS.notes).toBe(2000);
      });

      it('should be readonly', () => {
        expect(typeof HEALTH_FIELD_LIMITS).toBe('object');
        expect(Object.keys(HEALTH_FIELD_LIMITS)).toEqual(['condition', 'name', 'medication', 'notes']);
      });
    });

    describe('VULNERABILITY_FIELD_LIMITS', () => {
      it('should have correct field limit values', () => {
        expect(VULNERABILITY_FIELD_LIMITS.description).toBe(500);
        expect(VULNERABILITY_FIELD_LIMITS.adjustments).toBe(1000);
        expect(VULNERABILITY_FIELD_LIMITS.notes).toBe(2000);
      });

      it('should be readonly', () => {
        expect(typeof VULNERABILITY_FIELD_LIMITS).toBe('object');
        expect(Object.keys(VULNERABILITY_FIELD_LIMITS)).toEqual(['description', 'adjustments', 'notes']);
      });
    });

    describe('STATUS_OPTIONS', () => {
      it('should contain all valid status values in order', () => {
        expect(STATUS_OPTIONS).toEqual([
          'Active',
          'Resolved',
          'Monitoring',
          'Inactive',
        ]);
      });

      it('should be a readonly array', () => {
        expect(Array.isArray(STATUS_OPTIONS)).toBe(true);
        expect(STATUS_OPTIONS.length).toBe(4);
      });
    });
  });

  describe('Type Compatibility with Backend Models', () => {
    it('should match backend HealthProductOwner field types', () => {
      // This test ensures frontend types are compatible with backend Pydantic models
      const backendResponse: HealthProductOwner = {
        id: 1, // int
        product_owner_id: 100, // int
        condition: 'Diabetes', // string
        name: 'Type 2', // Optional[str]
        date_of_diagnosis: '2020-05-15', // ISO date string (backend sends date as string)
        status: 'Active', // Valid status enum
        medication: 'Metformin', // Optional[str]
        notes: 'Monitor regularly', // Optional[str]
        created_at: '2025-01-01T10:00:00Z', // datetime as ISO string
        date_recorded: null, // Optional[datetime]
      };

      expect(typeof backendResponse.id).toBe('number');
      expect(typeof backendResponse.product_owner_id).toBe('number');
      expect(typeof backendResponse.condition).toBe('string');
      expect(typeof backendResponse.created_at).toBe('string');
    });

    it('should match backend VulnerabilityProductOwner field types', () => {
      const backendResponse: VulnerabilityProductOwner = {
        id: 1, // int
        product_owner_id: 100, // int
        description: 'Cognitive decline', // string
        adjustments: 'Speak slowly', // Optional[str]
        diagnosed: true, // bool
        status: 'Active', // Valid status enum
        notes: 'Family involvement needed', // Optional[str]
        created_at: '2025-01-01T10:00:00Z', // datetime as ISO string
        date_recorded: null, // Optional[datetime]
      };

      expect(typeof backendResponse.id).toBe('number');
      expect(typeof backendResponse.product_owner_id).toBe('number');
      expect(typeof backendResponse.description).toBe('string');
      expect(typeof backendResponse.diagnosed).toBe('boolean');
      expect(typeof backendResponse.created_at).toBe('string');
    });

    it('should handle status values matching backend VALID_HEALTH_STATUSES', () => {
      // Backend defines: ["Active", "Resolved", "Monitoring", "Inactive"]
      const backendStatuses: HealthVulnerabilityStatus[] = [
        'Active',
        'Resolved',
        'Monitoring',
        'Inactive',
      ];

      backendStatuses.forEach(status => {
        const testStatus: HealthVulnerabilityStatus = status;
        expect(STATUS_OPTIONS).toContain(testStatus);
      });
    });
  });

  describe('Type Guards', () => {
    describe('isHealthProductOwner', () => {
      it('should return true for health records with product_owner_id', () => {
        const healthRecord: HealthProductOwner = {
          id: 1,
          product_owner_id: 100,
          condition: 'Diabetes',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        expect(isHealthProductOwner(healthRecord)).toBe(true);
      });

      it('should return false for health records with special_relationship_id', () => {
        const healthRecord: HealthSpecialRelationship = {
          id: 2,
          special_relationship_id: 200,
          condition: 'Diabetes',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        expect(isHealthProductOwner(healthRecord)).toBe(false);
      });

      it('should narrow type correctly in conditional', () => {
        const healthRecord: HealthCondition = {
          id: 1,
          product_owner_id: 100,
          condition: 'Diabetes',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        } as HealthProductOwner;

        if (isHealthProductOwner(healthRecord)) {
          // TypeScript should know this is HealthProductOwner
          expect(healthRecord.product_owner_id).toBe(100);
        }
      });
    });

    describe('isHealthSpecialRelationship', () => {
      it('should return true for health records with special_relationship_id', () => {
        const healthRecord: HealthSpecialRelationship = {
          id: 2,
          special_relationship_id: 200,
          condition: 'Dementia',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        expect(isHealthSpecialRelationship(healthRecord)).toBe(true);
      });

      it('should return false for health records with product_owner_id', () => {
        const healthRecord: HealthProductOwner = {
          id: 1,
          product_owner_id: 100,
          condition: 'Diabetes',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        expect(isHealthSpecialRelationship(healthRecord)).toBe(false);
      });

      it('should narrow type correctly in conditional', () => {
        const healthRecord: HealthCondition = {
          id: 2,
          special_relationship_id: 200,
          condition: 'Dementia',
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        } as HealthSpecialRelationship;

        if (isHealthSpecialRelationship(healthRecord)) {
          // TypeScript should know this is HealthSpecialRelationship
          expect(healthRecord.special_relationship_id).toBe(200);
        }
      });
    });

    describe('isVulnerabilityProductOwner', () => {
      it('should return true for vulnerability records with product_owner_id', () => {
        const vulnRecord: VulnerabilityProductOwner = {
          id: 1,
          product_owner_id: 100,
          description: 'Cognitive decline',
          diagnosed: true,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        expect(isVulnerabilityProductOwner(vulnRecord)).toBe(true);
      });

      it('should return false for vulnerability records with special_relationship_id', () => {
        const vulnRecord: VulnerabilitySpecialRelationship = {
          id: 2,
          special_relationship_id: 200,
          description: 'Recent bereavement',
          diagnosed: false,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        expect(isVulnerabilityProductOwner(vulnRecord)).toBe(false);
      });

      it('should narrow type correctly in conditional', () => {
        const vulnRecord: Vulnerability = {
          id: 1,
          product_owner_id: 100,
          description: 'Cognitive decline',
          diagnosed: true,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        } as VulnerabilityProductOwner;

        if (isVulnerabilityProductOwner(vulnRecord)) {
          // TypeScript should know this is VulnerabilityProductOwner
          expect(vulnRecord.product_owner_id).toBe(100);
        }
      });
    });

    describe('isVulnerabilitySpecialRelationship', () => {
      it('should return true for vulnerability records with special_relationship_id', () => {
        const vulnRecord: VulnerabilitySpecialRelationship = {
          id: 2,
          special_relationship_id: 200,
          description: 'Recent bereavement',
          diagnosed: false,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        expect(isVulnerabilitySpecialRelationship(vulnRecord)).toBe(true);
      });

      it('should return false for vulnerability records with product_owner_id', () => {
        const vulnRecord: VulnerabilityProductOwner = {
          id: 1,
          product_owner_id: 100,
          description: 'Cognitive decline',
          diagnosed: true,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        };

        expect(isVulnerabilitySpecialRelationship(vulnRecord)).toBe(false);
      });

      it('should narrow type correctly in conditional', () => {
        const vulnRecord: Vulnerability = {
          id: 2,
          special_relationship_id: 200,
          description: 'Recent bereavement',
          diagnosed: false,
          status: 'Active',
          created_at: '2025-01-01T00:00:00Z',
        } as VulnerabilitySpecialRelationship;

        if (isVulnerabilitySpecialRelationship(vulnRecord)) {
          // TypeScript should know this is VulnerabilitySpecialRelationship
          expect(vulnRecord.special_relationship_id).toBe(200);
        }
      });
    });
  });

  describe('Date Utilities', () => {
    describe('parseHealthDate', () => {
      it('should parse valid ISO date string', () => {
        const result = parseHealthDate('2025-01-15');
        expect(result).toBeInstanceOf(Date);
        expect(result?.getFullYear()).toBe(2025);
        expect(result?.getMonth()).toBe(0); // January is 0
        expect(result?.getDate()).toBe(15);
      });

      it('should parse full ISO 8601 datetime string', () => {
        const result = parseHealthDate('2025-01-15T10:30:00Z');
        expect(result).toBeInstanceOf(Date);
        expect(result?.getFullYear()).toBe(2025);
      });

      it('should return null for null input', () => {
        const result = parseHealthDate(null);
        expect(result).toBeNull();
      });

      it('should return null for undefined input', () => {
        const result = parseHealthDate(undefined);
        expect(result).toBeNull();
      });

      it('should return null for empty string', () => {
        const result = parseHealthDate('');
        expect(result).toBeNull();
      });

      it('should return null for invalid date string', () => {
        const result = parseHealthDate('not-a-date');
        expect(result).toBeNull();
      });

      it('should return null for malformed date string', () => {
        const result = parseHealthDate('2025-99-99');
        // JavaScript Date constructor may create an invalid date
        expect(result).toBeNull();
      });
    });

    describe('formatHealthDate', () => {
      it('should format Date object to YYYY-MM-DD string', () => {
        const date = new Date('2025-01-15T00:00:00Z');
        const result = formatHealthDate(date);
        expect(result).toBe('2025-01-15');
      });

      it('should return null for null input', () => {
        const result = formatHealthDate(null);
        expect(result).toBeNull();
      });

      it('should return null for undefined input', () => {
        const result = formatHealthDate(undefined);
        expect(result).toBeNull();
      });

      it('should handle dates with time component', () => {
        const date = new Date('2025-06-20T15:30:45Z');
        const result = formatHealthDate(date);
        expect(result).toBe('2025-06-20');
      });

      it('should round-trip correctly with parseHealthDate', () => {
        const originalDateStr = '2025-03-10';
        const parsed = parseHealthDate(originalDateStr);
        const formatted = formatHealthDate(parsed);
        expect(formatted).toBe(originalDateStr);
      });
    });
  });
});
