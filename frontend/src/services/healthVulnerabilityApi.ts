/**
 * Health and Vulnerability API Service
 *
 * Provides API functions for managing health conditions and vulnerabilities
 * for product owners and special relationships in the Phase 2 Health &
 * Vulnerabilities Tab implementation.
 *
 * All functions handle routing to the correct endpoint based on person type
 * and provide consistent error handling across operations.
 *
 * API Endpoints:
 * - Health Conditions:
 *   - GET /health/product-owners - Fetch health records for product owners
 *   - GET /health/special-relationships - Fetch health records for special relationships
 *   - POST /health/product-owners - Create health record for product owner
 *   - POST /health/special-relationships - Create health record for special relationship
 *   - PUT /health/product-owners/:id - Update health record
 *   - PUT /health/special-relationships/:id - Update health record
 *   - DELETE /health/product-owners/:id - Delete health record
 *   - DELETE /health/special-relationships/:id - Delete health record
 *
 * - Vulnerabilities:
 *   - GET /vulnerabilities/product-owners - Fetch vulnerabilities for product owners
 *   - GET /vulnerabilities/special-relationships - Fetch vulnerabilities for special relationships
 *   - POST /vulnerabilities/product-owners - Create vulnerability for product owner
 *   - POST /vulnerabilities/special-relationships - Create vulnerability for special relationship
 *   - PUT /vulnerabilities/product-owners/:id - Update vulnerability
 *   - PUT /vulnerabilities/special-relationships/:id - Update vulnerability
 *   - DELETE /vulnerabilities/product-owners/:id - Delete vulnerability
 *   - DELETE /vulnerabilities/special-relationships/:id - Delete vulnerability
 *
 * @module services/healthVulnerabilityApi
 */

import api from '@/services/api';
import type {
  HealthProductOwner,
  HealthSpecialRelationship,
  VulnerabilityProductOwner,
  VulnerabilitySpecialRelationship,
  HealthProductOwnerCreate,
  HealthSpecialRelationshipCreate,
  HealthConditionUpdate,
  VulnerabilityProductOwnerCreate,
  VulnerabilitySpecialRelationshipCreate,
  VulnerabilityUpdate,
  PersonType,
} from '@/types/healthVulnerability';
import { HEALTH_FIELD_LIMITS, VULNERABILITY_FIELD_LIMITS } from '@/types/healthVulnerability';

// =============================================================================
// Validation Types
// =============================================================================

/**
 * A single validation error for a specific field
 */
export interface ValidationError {
  /** The field that has the validation error */
  field: string;
  /** User-friendly error message describing the issue */
  message: string;
}

/**
 * Result of validating form data
 */
export interface ValidationResult {
  /** Whether the data passed all validation checks */
  isValid: boolean;
  /** Array of validation errors (empty if isValid is true) */
  errors: ValidationError[];
}

// =============================================================================
// User-Friendly Error Messages
// =============================================================================

/**
 * User-friendly error messages for common API HTTP status codes
 */
const ERROR_MESSAGES: Record<number, string> = {
  400: 'The request contains invalid data. Please check your input.',
  401: 'Your session has expired. Please log in again.',
  403: 'You do not have permission to perform this action.',
  404: 'The requested record was not found.',
  422: 'The provided data is invalid. Please check the required fields.',
  500: 'An unexpected error occurred. Please try again later.',
};

/**
 * Maps API errors to user-friendly messages.
 * Handles various error formats including axios errors and network errors.
 *
 * @param error - The error object from an API call
 * @returns A user-friendly error message
 *
 * @example
 * ```ts
 * try {
 *   await createHealthRecord(data, 'product_owner');
 * } catch (error) {
 *   const message = getUserFriendlyErrorMessage(error);
 *   showToast(message); // "The request contains invalid data..."
 * }
 * ```
 */
export function getUserFriendlyErrorMessage(error: unknown): string {
  if (error && typeof error === 'object') {
    const axiosError = error as {
      response?: {
        status?: number;
        data?: {
          message?: string;
          error?: string;
          detail?: string;
        };
      };
      code?: string;
      message?: string;
    };

    // Check for axios error with response status
    if (axiosError.response?.status) {
      const status = axiosError.response.status;

      // First try to get a specific message from the response
      if (axiosError.response.data?.message) {
        return axiosError.response.data.message;
      }
      if (axiosError.response.data?.detail) {
        return axiosError.response.data.detail;
      }

      // Fall back to standard message for the status code
      return ERROR_MESSAGES[status] || `An error occurred (${status}). Please try again.`;
    }

    // Network error
    if (axiosError.code === 'ERR_NETWORK') {
      return 'Unable to connect to the server. Please check your internet connection.';
    }

    // Timeout error
    if (axiosError.code === 'ECONNABORTED') {
      return 'The request took too long. Please try again.';
    }
  }

  return 'An unexpected error occurred. Please try again.';
}

// =============================================================================
// Validation Functions
// =============================================================================

/**
 * Validates health condition data before API submission.
 * Checks required fields, field length limits, and date constraints.
 *
 * @param data - Partial health condition data to validate
 * @returns ValidationResult with isValid flag and array of errors
 *
 * @example
 * ```ts
 * const result = validateHealthData({ condition: '', medication: 'A'.repeat(600) });
 * if (!result.isValid) {
 *   result.errors.forEach(err => console.log(`${err.field}: ${err.message}`));
 *   // condition: Condition is required
 *   // medication: Medication must be 500 characters or less
 * }
 * ```
 */
export function validateHealthData(
  data: Partial<HealthProductOwnerCreate | HealthSpecialRelationshipCreate>
): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate condition (required)
  if (!data.condition || data.condition.trim().length === 0) {
    errors.push({ field: 'condition', message: 'Condition is required' });
  } else if (data.condition.length > HEALTH_FIELD_LIMITS.condition) {
    errors.push({
      field: 'condition',
      message: `Condition must be ${HEALTH_FIELD_LIMITS.condition} characters or less`,
    });
  }

  // Validate name (optional, max length)
  if (data.name && data.name.length > HEALTH_FIELD_LIMITS.name) {
    errors.push({
      field: 'name',
      message: `Name must be ${HEALTH_FIELD_LIMITS.name} characters or less`,
    });
  }

  // Validate medication (optional, max length)
  if (data.medication && data.medication.length > HEALTH_FIELD_LIMITS.medication) {
    errors.push({
      field: 'medication',
      message: `Medication must be ${HEALTH_FIELD_LIMITS.medication} characters or less`,
    });
  }

  // Validate notes (optional, max length)
  if (data.notes && data.notes.length > HEALTH_FIELD_LIMITS.notes) {
    errors.push({
      field: 'notes',
      message: `Notes must be ${HEALTH_FIELD_LIMITS.notes} characters or less`,
    });
  }

  // Validate date_of_diagnosis is not in the future
  if (data.date_of_diagnosis) {
    const diagDate = new Date(data.date_of_diagnosis);
    if (!isNaN(diagDate.getTime()) && diagDate > new Date()) {
      errors.push({
        field: 'date_of_diagnosis',
        message: 'Diagnosis date cannot be in the future',
      });
    }
  }

  return { isValid: errors.length === 0, errors };
}

/**
 * Validates vulnerability data before API submission.
 * Checks required fields and field length limits.
 *
 * @param data - Partial vulnerability data to validate
 * @returns ValidationResult with isValid flag and array of errors
 *
 * @example
 * ```ts
 * const result = validateVulnerabilityData({ description: '' });
 * if (!result.isValid) {
 *   result.errors.forEach(err => console.log(`${err.field}: ${err.message}`));
 *   // description: Description is required
 * }
 * ```
 */
export function validateVulnerabilityData(
  data: Partial<VulnerabilityProductOwnerCreate | VulnerabilitySpecialRelationshipCreate>
): ValidationResult {
  const errors: ValidationError[] = [];

  // Validate description (required)
  if (!data.description || data.description.trim().length === 0) {
    errors.push({ field: 'description', message: 'Description is required' });
  } else if (data.description.length > VULNERABILITY_FIELD_LIMITS.description) {
    errors.push({
      field: 'description',
      message: `Description must be ${VULNERABILITY_FIELD_LIMITS.description} characters or less`,
    });
  }

  // Validate adjustments (optional, max length)
  if (data.adjustments && data.adjustments.length > VULNERABILITY_FIELD_LIMITS.adjustments) {
    errors.push({
      field: 'adjustments',
      message: `Adjustments must be ${VULNERABILITY_FIELD_LIMITS.adjustments} characters or less`,
    });
  }

  // Validate notes (optional, max length)
  if (data.notes && data.notes.length > VULNERABILITY_FIELD_LIMITS.notes) {
    errors.push({
      field: 'notes',
      message: `Notes must be ${VULNERABILITY_FIELD_LIMITS.notes} characters or less`,
    });
  }

  return { isValid: errors.length === 0, errors };
}

// =============================================================================
// Debounce Utility
// =============================================================================

/**
 * Creates a debounced version of a function.
 * The function will only be called after the specified delay has passed
 * without any new calls.
 *
 * @param fn - The function to debounce
 * @param delay - The delay in milliseconds
 * @returns A debounced version of the function
 *
 * @example
 * ```ts
 * const debouncedSave = debounce(saveData, 300);
 * // Multiple rapid calls will only result in one saveData call after 300ms
 * debouncedSave(data1);
 * debouncedSave(data2);
 * debouncedSave(data3); // Only this one will execute after 300ms
 * ```
 */
export function debounce<T extends (...args: Parameters<T>) => ReturnType<T>>(
  fn: T,
  delay: number
): (...args: Parameters<T>) => void {
  let timeoutId: ReturnType<typeof setTimeout>;
  return (...args: Parameters<T>) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => fn(...args), delay);
  };
}

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Gets the endpoint path suffix based on person type.
 * Maps PersonType to the correct API path segment.
 *
 * @param personType - The type of person ('product_owner' or 'special_relationship')
 * @returns The API path segment for the person type
 */
function getEndpointSuffix(personType: PersonType): string {
  return personType === 'product_owner' ? 'product-owners' : 'special-relationships';
}

/**
 * Extracts error message from API error response.
 * Handles various error response formats from the backend.
 *
 * @param error - The error object from axios
 * @returns A user-friendly error message
 */
function extractErrorMessage(error: unknown): string {
  if (error && typeof error === 'object') {
    const err = error as {
      response?: {
        data?: {
          message?: string;
          error?: string;
          detail?: string;
        };
      };
      message?: string;
    };

    // Try to extract message from various error formats
    if (err.response?.data?.message) {
      return err.response.data.message;
    }
    if (err.response?.data?.detail) {
      return err.response.data.detail;
    }
    if (err.response?.data?.error) {
      return err.response.data.error;
    }
    if (err.message) {
      return err.message;
    }
  }
  return 'An unexpected error occurred';
}

/**
 * Wraps an API call with consistent error handling.
 * Throws an error with a user-friendly message extracted from the response.
 *
 * @param apiCall - The API call promise to wrap
 * @returns The data from the successful API response
 * @throws Error with extracted message on failure
 */
async function handleApiError<T>(apiCall: Promise<{ data: T }>): Promise<T> {
  try {
    const response = await apiCall;
    return response.data;
  } catch (error) {
    throw new Error(extractErrorMessage(error));
  }
}

// =============================================================================
// Health Conditions - Fetch Functions
// =============================================================================

/**
 * Fetches health condition records for product owners.
 *
 * @param clientGroupId - The client group ID to filter by
 * @returns Array of health condition records for product owners
 * @throws Error if the request fails (401 Unauthorized, 500 Server Error, etc.)
 *
 * @example
 * ```ts
 * const healthRecords = await fetchHealthProductOwners(50);
 * console.log(`Found ${healthRecords.length} health records`);
 * ```
 */
export async function fetchHealthProductOwners(
  clientGroupId: number
): Promise<HealthProductOwner[]> {
  return handleApiError(
    api.get<HealthProductOwner[]>('/health/product-owners', {
      params: { client_group_id: clientGroupId },
    })
  );
}

/**
 * Fetches health condition records for special relationships.
 *
 * @param clientGroupId - The client group ID to filter by
 * @returns Array of health condition records for special relationships
 * @throws Error if the request fails (401 Unauthorized, 500 Server Error, etc.)
 *
 * @example
 * ```ts
 * const healthRecords = await fetchHealthSpecialRelationships(50);
 * console.log(`Found ${healthRecords.length} health records`);
 * ```
 */
export async function fetchHealthSpecialRelationships(
  clientGroupId: number
): Promise<HealthSpecialRelationship[]> {
  return handleApiError(
    api.get<HealthSpecialRelationship[]>('/health/special-relationships', {
      params: { client_group_id: clientGroupId },
    })
  );
}

// =============================================================================
// Health Conditions - Mutation Functions
// =============================================================================

/**
 * Creates a new health condition record.
 * Routes to the correct endpoint based on person type.
 *
 * @param data - The health condition data to create
 * @param personType - The type of person ('product_owner' or 'special_relationship')
 * @returns The created health condition record
 * @throws Error if validation fails (422), person not found (404), or server error (500)
 *
 * @example
 * ```ts
 * // Create health record for product owner
 * const record = await createHealthRecord(
 *   { product_owner_id: 100, condition: 'Diabetes', status: 'Active' },
 *   'product_owner'
 * );
 *
 * // Create health record for special relationship
 * const record = await createHealthRecord(
 *   { special_relationship_id: 200, condition: 'Dementia', status: 'Active' },
 *   'special_relationship'
 * );
 * ```
 */
export async function createHealthRecord(
  data: HealthProductOwnerCreate | HealthSpecialRelationshipCreate,
  personType: PersonType
): Promise<HealthProductOwner | HealthSpecialRelationship> {
  const endpoint = `/health/${getEndpointSuffix(personType)}`;
  return handleApiError(
    api.post<HealthProductOwner | HealthSpecialRelationship>(endpoint, data)
  );
}

/**
 * Updates an existing health condition record.
 * Routes to the correct endpoint based on person type.
 *
 * @param id - The ID of the health record to update
 * @param data - The fields to update (partial update supported)
 * @param personType - The type of person ('product_owner' or 'special_relationship')
 * @returns The updated health condition record
 * @throws Error if record not found (404), validation fails (422), or server error (500)
 *
 * @example
 * ```ts
 * const updated = await updateHealthRecord(
 *   1,
 *   { status: 'Resolved', notes: 'Condition resolved' },
 *   'product_owner'
 * );
 * ```
 */
export async function updateHealthRecord(
  id: number,
  data: HealthConditionUpdate,
  personType: PersonType
): Promise<HealthProductOwner | HealthSpecialRelationship> {
  const endpoint = `/health/${getEndpointSuffix(personType)}/${id}`;
  return handleApiError(
    api.put<HealthProductOwner | HealthSpecialRelationship>(endpoint, data)
  );
}

/**
 * Deletes a health condition record.
 * Routes to the correct endpoint based on person type.
 *
 * @param id - The ID of the health record to delete
 * @param personType - The type of person ('product_owner' or 'special_relationship')
 * @throws Error if record not found (404), unauthorized (401), or server error (500)
 *
 * @example
 * ```ts
 * await deleteHealthRecord(1, 'product_owner');
 * console.log('Health record deleted successfully');
 * ```
 */
export async function deleteHealthRecord(
  id: number,
  personType: PersonType
): Promise<void> {
  const endpoint = `/health/${getEndpointSuffix(personType)}/${id}`;
  await handleApiError(api.delete(endpoint));
}

// =============================================================================
// Vulnerabilities - Fetch Functions
// =============================================================================

/**
 * Fetches vulnerability records for product owners.
 *
 * @param clientGroupId - The client group ID to filter by
 * @returns Array of vulnerability records for product owners
 * @throws Error if the request fails (401 Unauthorized, 500 Server Error, etc.)
 *
 * @example
 * ```ts
 * const vulnerabilities = await fetchVulnerabilitiesProductOwners(50);
 * console.log(`Found ${vulnerabilities.length} vulnerability records`);
 * ```
 */
export async function fetchVulnerabilitiesProductOwners(
  clientGroupId: number
): Promise<VulnerabilityProductOwner[]> {
  return handleApiError(
    api.get<VulnerabilityProductOwner[]>('/vulnerabilities/product-owners', {
      params: { client_group_id: clientGroupId },
    })
  );
}

/**
 * Fetches vulnerability records for special relationships.
 *
 * @param clientGroupId - The client group ID to filter by
 * @returns Array of vulnerability records for special relationships
 * @throws Error if the request fails (401 Unauthorized, 500 Server Error, etc.)
 *
 * @example
 * ```ts
 * const vulnerabilities = await fetchVulnerabilitiesSpecialRelationships(50);
 * console.log(`Found ${vulnerabilities.length} vulnerability records`);
 * ```
 */
export async function fetchVulnerabilitiesSpecialRelationships(
  clientGroupId: number
): Promise<VulnerabilitySpecialRelationship[]> {
  return handleApiError(
    api.get<VulnerabilitySpecialRelationship[]>('/vulnerabilities/special-relationships', {
      params: { client_group_id: clientGroupId },
    })
  );
}

// =============================================================================
// Vulnerabilities - Mutation Functions
// =============================================================================

/**
 * Creates a new vulnerability record.
 * Routes to the correct endpoint based on person type.
 *
 * @param data - The vulnerability data to create
 * @param personType - The type of person ('product_owner' or 'special_relationship')
 * @returns The created vulnerability record
 * @throws Error if validation fails (422), person not found (404), or server error (500)
 *
 * @example
 * ```ts
 * // Create vulnerability for product owner
 * const record = await createVulnerability(
 *   { product_owner_id: 100, description: 'Cognitive decline', diagnosed: true },
 *   'product_owner'
 * );
 *
 * // Create vulnerability for special relationship
 * const record = await createVulnerability(
 *   { special_relationship_id: 200, description: 'Recent bereavement' },
 *   'special_relationship'
 * );
 * ```
 */
export async function createVulnerability(
  data: VulnerabilityProductOwnerCreate | VulnerabilitySpecialRelationshipCreate,
  personType: PersonType
): Promise<VulnerabilityProductOwner | VulnerabilitySpecialRelationship> {
  const endpoint = `/vulnerabilities/${getEndpointSuffix(personType)}`;
  return handleApiError(
    api.post<VulnerabilityProductOwner | VulnerabilitySpecialRelationship>(endpoint, data)
  );
}

/**
 * Updates an existing vulnerability record.
 * Routes to the correct endpoint based on person type.
 *
 * @param id - The ID of the vulnerability record to update
 * @param data - The fields to update (partial update supported)
 * @param personType - The type of person ('product_owner' or 'special_relationship')
 * @returns The updated vulnerability record
 * @throws Error if record not found (404), validation fails (422), or server error (500)
 *
 * @example
 * ```ts
 * const updated = await updateVulnerability(
 *   1,
 *   { status: 'Resolved', notes: 'Vulnerability addressed' },
 *   'product_owner'
 * );
 * ```
 */
export async function updateVulnerability(
  id: number,
  data: VulnerabilityUpdate,
  personType: PersonType
): Promise<VulnerabilityProductOwner | VulnerabilitySpecialRelationship> {
  const endpoint = `/vulnerabilities/${getEndpointSuffix(personType)}/${id}`;
  return handleApiError(
    api.put<VulnerabilityProductOwner | VulnerabilitySpecialRelationship>(endpoint, data)
  );
}

/**
 * Deletes a vulnerability record.
 * Routes to the correct endpoint based on person type.
 *
 * @param id - The ID of the vulnerability record to delete
 * @param personType - The type of person ('product_owner' or 'special_relationship')
 * @throws Error if record not found (404), unauthorized (401), or server error (500)
 *
 * @example
 * ```ts
 * await deleteVulnerability(1, 'product_owner');
 * console.log('Vulnerability record deleted successfully');
 * ```
 */
export async function deleteVulnerability(
  id: number,
  personType: PersonType
): Promise<void> {
  const endpoint = `/vulnerabilities/${getEndpointSuffix(personType)}/${id}`;
  await handleApiError(api.delete(endpoint));
}
